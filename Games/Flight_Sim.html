<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Flight Sim</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            /* Sky Blue */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .controls {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .key {
            display: inline-block;
            background: #ddd;
            color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
        }

        #speedometer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
    </style>
    <!-- Import Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div id="ui">
        <h1>Flight Sim</h1>
        <div class="controls">
            <div><span class="key">W</span> Pitch Down</div>
            <div><span class="key">S</span> Pitch Up</div>
            <div><span class="key">A</span> Roll Left</div>
            <div><span class="key">D</span> Roll Right</div>
            <div><span class="key">Shift</span> Turbo</div>
            <div><span class="key">Space</span> Brake</div>
        </div>
    </div>

    <div id="speedometer">SPEED: 000</div>

    <div id="canvas-container"></div>

    <script>
        // --- CONFIGURATION ---
        const WORLD_SIZE = 4000; // Size of the ground plane
        const CUBE_COUNT = 500;  // Number of random buildings/trees
        const FOG_COLOR = 0xd6eaf8;
        const FOG_DENSITY = 0.002;

        // --- GLOBALS ---
        let scene, camera, renderer;
        let plane, propeller;
        let terrainGroup;
        let speed = 0;
        const baseSpeed = 2.0;
        const maxSpeed = 4.5;
        const minSpeed = 1.0;

        // Input state
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            shift: false,
            space: false
        };

        // --- INITIALIZATION ---
        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(FOG_COLOR);
            scene.fog = new THREE.FogExp2(FOG_COLOR, FOG_DENSITY);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 10, 20);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 500;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            scene.add(dirLight);

            // 5. Create World
            createPlane();
            createTerrain();

            // 6. Listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', (e) => handleKey(e, true), false);
            window.addEventListener('keyup', (e) => handleKey(e, false), false);

            // Start Loop
            animate();
        }

        // --- OBJECT CREATION ---

        function createPlane() {
            plane = new THREE.Group();

            // Materials (Flat shading for low-poly look)
            const redMat = new THREE.MeshStandardMaterial({ color: 0xd9534f, flatShading: true });
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xf7f7f7, flatShading: true });
            const greyMat = new THREE.MeshStandardMaterial({ color: 0x333333, flatShading: true });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB, opacity: 0.7, transparent: true });

            // Fuselage
            const fuselageGeo = new THREE.BoxGeometry(1.5, 1.5, 8);
            // Taper the front of the fuselage slightly
            const positionAttribute = fuselageGeo.attributes.position;
            for (let i = 0; i < positionAttribute.count; i++) {
                const z = positionAttribute.getZ(i);
                if (z < -2) { // Front of plane
                    const scale = 0.7;
                    positionAttribute.setX(i, positionAttribute.getX(i) * scale);
                    positionAttribute.setY(i, positionAttribute.getY(i) * scale);
                }
            }
            fuselageGeo.computeVertexNormals();
            const fuselage = new THREE.Mesh(fuselageGeo, whiteMat);
            fuselage.castShadow = true;
            fuselage.receiveShadow = true;
            plane.add(fuselage);

            // Cockpit
            const cockpitGeo = new THREE.BoxGeometry(1.2, 0.8, 2.5);
            const cockpit = new THREE.Mesh(cockpitGeo, glassMat);
            cockpit.position.set(0, 0.8, -1);
            plane.add(cockpit);

            // Wings
            const wingGeo = new THREE.BoxGeometry(12, 0.2, 3);
            const wing = new THREE.Mesh(wingGeo, redMat);
            wing.position.set(0, 0, 0.5);
            wing.castShadow = true;
            plane.add(wing);

            // Tail (Vertical)
            const tailVGeo = new THREE.BoxGeometry(0.2, 2.5, 2);
            const tailV = new THREE.Mesh(tailVGeo, redMat);
            tailV.position.set(0, 1, 3.5);
            tailV.castShadow = true;
            plane.add(tailV);

            // Tail (Horizontal)
            const tailHGeo = new THREE.BoxGeometry(4, 0.2, 1.5);
            const tailH = new THREE.Mesh(tailHGeo, redMat);
            tailH.position.set(0, 0.5, 3.5);
            tailH.castShadow = true;
            plane.add(tailH);

            // Propeller Spinner
            const spinnerGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const spinner = new THREE.Mesh(spinnerGeo, redMat);
            spinner.position.set(0, 0, -4.1);
            plane.add(spinner);

            // Propeller Blades
            const propGeo = new THREE.BoxGeometry(5, 0.1, 0.3);
            propeller = new THREE.Mesh(propGeo, greyMat);
            propeller.position.set(0, 0, -4.1);
            plane.add(propeller);

            // Initial Position
            plane.position.y = 50;
            scene.add(plane);
        }

        function createTerrain() {
            terrainGroup = new THREE.Group();

            // Ground Plane
            const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x58d68d, roughness: 1, flatShading: true });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            terrainGroup.add(ground);

            // Random Obstacles (Trees/Buildings)
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            // Reuse geometry for performance
            const colors = [0x2ecc71, 0x27ae60, 0xf1c40f, 0xe67e22, 0x95a5a6];

            for (let i = 0; i < CUBE_COUNT; i++) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                const material = new THREE.MeshStandardMaterial({ color: color, flatShading: true });
                const mesh = new THREE.Mesh(boxGeo, material);

                // Random position
                const x = (Math.random() - 0.5) * WORLD_SIZE;
                const z = (Math.random() - 0.5) * WORLD_SIZE;
                const h = Math.random() * 30 + 5; // Height
                const w = Math.random() * 10 + 5; // Width

                mesh.position.set(x, h / 2, z);
                mesh.scale.set(w, h, w);
                mesh.castShadow = true;
                mesh.receiveShadow = true;

                // Don't put obstacles in the starting area
                if (Math.abs(x) > 100 || Math.abs(z) > 100) {
                    terrainGroup.add(mesh);
                }
            }

            scene.add(terrainGroup);
        }

        // --- INPUT HANDLING ---
        function handleKey(event, isDown) {
            const k = event.key.toLowerCase();
            if (k === 'w') keys.w = isDown;
            if (k === 's') keys.s = isDown;
            if (k === 'a') keys.a = isDown;
            if (k === 'd') keys.d = isDown;
            if (event.key === 'Shift') keys.shift = isDown;
            if (event.key === ' ') keys.space = isDown;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- PHYSICS & LOGIC ---
        function updatePlane() {
            // 1. Handle Speed
            let targetSpeed = baseSpeed;
            if (keys.shift) targetSpeed = maxSpeed;
            if (keys.space) targetSpeed = minSpeed;

            // Simple linear interpolation for smooth acceleration/deceleration
            speed += (targetSpeed - speed) * 0.05;

            // Update Speedometer UI
            document.getElementById('speedometer').innerText = `SPEED: ${Math.round(speed * 100)}`;

            // 2. Handle Rotation (Local Axis)
            const pitchSpeed = 0.03;
            const rollSpeed = 0.04;

            // Pitch (W/S)
            if (keys.w) plane.rotateX(pitchSpeed);
            if (keys.s) plane.rotateX(-pitchSpeed);

            // Roll (A/D) - Also adding a tiny bit of yaw for realism
            if (keys.a) {
                plane.rotateZ(rollSpeed);
                plane.rotateY(0.01); // Slight yaw left
            }
            if (keys.d) {
                plane.rotateZ(-rollSpeed);
                plane.rotateY(-0.01); // Slight yaw right
            }

            // 3. Move Forward
            // TranslateZ moves the object along its LOCAL Z axis.
            // In Three.js, "Forward" is typically negative Z.
            plane.translateZ(-speed);

            // 4. Propeller Animation
            propeller.rotation.z += 0.8 + (speed * 0.2);

            // 5. Simple Floor Collision
            if (plane.position.y < 2) {
                plane.position.y = 2;
                // Level out if hitting ground
                plane.rotation.x = 0;
                plane.rotation.z = 0;
            }
        }

        function updateCamera() {
            // Third Person Camera Logic
            // We want the camera to trail behind the plane, but not be rigidly locked.
            // We calculate the ideal position (behind and above local plane coords)
            // and then lerp (linear interpolate) the camera there.

            // Calculate ideal offset in World Space
            // (0, 6, 15) means: 0 left/right, 6 up, 15 behind the plane
            const idealOffset = new THREE.Vector3(0, 6, 15);
            idealOffset.applyMatrix4(plane.matrixWorld);

            // Also calculate where the camera should LOOK (forward of the plane)
            const idealLookat = new THREE.Vector3(0, 0, -20);
            idealLookat.applyMatrix4(plane.matrixWorld);

            // Smoothly move camera current pos -> ideal pos
            // The factor 0.1 determines how "tight" the camera follows. 
            // Lower = looser/more cinematic. Higher = tighter.
            camera.position.lerp(idealOffset, 0.1);

            // Make camera look ahead of the plane
            camera.lookAt(idealLookat);
        }

        function checkBoundaries() {
            // Infinite World Hack:
            // If the plane flies too far from the center (0,0), we move the terrain
            // to be under the plane. This is cheaper than generating new chunks.
            // It gives the illusion of infinite flight over a repetitive landscape.

            const threshold = WORLD_SIZE / 2 - 200; // When getting close to edge

            if (plane.position.x > terrainGroup.position.x + threshold) {
                terrainGroup.position.x += WORLD_SIZE;
            } else if (plane.position.x < terrainGroup.position.x - threshold) {
                terrainGroup.position.x -= WORLD_SIZE;
            }

            if (plane.position.z > terrainGroup.position.z + threshold) {
                terrainGroup.position.z += WORLD_SIZE;
            } else if (plane.position.z < terrainGroup.position.z - threshold) {
                terrainGroup.position.z -= WORLD_SIZE;
            }
        }

        // --- GAME LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            updatePlane();
            updateCamera();
            checkBoundaries();

            renderer.render(scene, camera);
        }

        // Run
        init();

    </script>
</body>

</html>