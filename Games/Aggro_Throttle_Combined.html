<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D RPG + Flight Sim Combined</title>
    <style>
        /* Basic styling */
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background-color: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        /* Info text container */
        .info-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
            max-width: 280px;
        }

        #ability-info {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        #ability-info h4 {
            margin: 0 0 5px 0;
            font-size: 1.1em;
            font-weight: bold;
        }

        #ability-info p {
            margin: 2px 0;
            font-size: 0.95em;
        }

        /* --- RPG UI --- */
        #ability-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
        }

        .ability-button {
            width: 50px;
            height: 50px;
            background-color: #333;
            border: 2px solid #555;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s, opacity 0.1s;
            position: relative;
        }

        .ability-button:hover {
            background-color: #444;
            border-color: #777;
        }

        .ability-button:active {
            background-color: #222;
            border-color: #444;
        }

        .keybind {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
        }

        .ability-text {
            font-size: 18px;
        }

        .ability-button.on-cooldown {
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed;
        }

        .ability-button.on-cooldown:hover {
            background-color: #333;
            border-color: #555;
        }

        #combat-log {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 250px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: white;
            font-size: 12px;
            padding: 5px;
            overflow-y: scroll;
            z-index: 100;
            display: flex;
            flex-direction: column-reverse;
        }

        #combat-log p {
            margin: 1px 0;
            line-height: 1.2;
        }

        /* --- Vehicle UI --- */
        #speedometer {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 10;
            min-width: 100px;
            text-align: center;
            display: none;
        }

        #nitro-ui {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
            width: 150px;
            text-align: left;
            display: none;
        }

        #nitro-bar-container {
            width: 100%;
            height: 10px;
            background-color: #555;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 4px;
        }

        #nitro-bar {
            width: 100%;
            height: 100%;
            background-color: #00ccff;
            border-radius: 3px;
            transition: width 0.1s linear;
        }

        /* --- General UI --- */
        .hp-label {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            transform: translateX(-50%);
            z-index: 99;
            display: none;
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: #ff4444;
            font-size: 48px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 300;
            display: none;
            cursor: default;
        }

        #interaction-prompt {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 101;
            display: none;
            white-space: nowrap;
        }

        /* Flight controls help */
        #flight-controls {
            display: none;
            font-size: 0.9em;
            color: #aaa;
            margin-top: 5px;
            border-top: 1px solid #444;
            padding-top: 5px;
        }
    </style>
</head>

<body>
    <div class="info-container">
        <div id="movement-info">
            WASD: Move<br>
            Space: Jump/Drift/Brake<br>
            LShift: Nitro/Turbo<br>
            E: Enter/Exit Vehicle<br>
            Click: Target, Drag: Rotate
            <div id="flight-controls">
                <b>Plane Controls:</b><br>
                W/S: Pitch Down/Up<br>
                A/D: Roll Left/Right<br>
                Shift: Fast | Space: Slow
            </div>
        </div>
        <div id="ability-info">
            <h4>Abilities (On Foot):</h4>
            <p>1 (‚öîÔ∏è): Attack</p>
            <p>2 (üõ°Ô∏è): Defend</p>
            <p>3 (üî•): Fireball</p>
            <p>4 (‚ùÑÔ∏è): Frost Nova</p>
            <p>5 (‚ú®): Heal</p>
        </div>
    </div>

    <div id="player-hp-label" class="hp-label"></div>
    <div id="ability-bar">
        <button class="ability-button" id="ability-1"><span class="keybind">1</span><span
                class="ability-text">‚öîÔ∏è</span></button>
        <button class="ability-button" id="ability-2"><span class="keybind">2</span><span
                class="ability-text">üõ°Ô∏è</span></button>
        <button class="ability-button" id="ability-3"><span class="keybind">3</span><span
                class="ability-text">üî•</span></button>
        <button class="ability-button" id="ability-4"><span class="keybind">4</span><span
                class="ability-text">‚ùÑÔ∏è</span></button>
        <button class="ability-button" id="ability-5"><span class="keybind">5</span><span
                class="ability-text">‚ú®</span></button>
    </div>
    <div id="combat-log"></div>

    <div id="speedometer">Speed: 0</div>
    <div id="nitro-ui">
        Turbo/Nitro:
        <div id="nitro-bar-container">
            <div id="nitro-bar"></div>
        </div>
    </div>

    <div id="interaction-prompt">Press [E] to Enter</div>
    <div id="game-over">YOU DIED</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Core Three.js Variables ---
        let scene, camera, renderer;
        let clock = new THREE.Clock();
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let activeVisualEffects = [];

        // --- Game Objects ---
        let player;
        let car;
        let carBodyMesh;
        let plane; // New Plane Object
        let propeller; // New Propeller
        let enemies = [];
        let environmentObjects = [];
        let environmentBoundingBoxes = [];
        let enemyBoundingBoxes = [];

        // --- Player State ---
        let playerState = 'onFoot'; // 'onFoot', 'inCar', 'inPlane'
        let playerMaxHP = 100;
        let playerCurrentHP = playerMaxHP;
        let isPlayerDead = false;
        let isPlayerImmune = false;
        let playerImmunityEndTime = 0;
        let immunityVisual = null;
        const playerModelHeight = 1.8;
        const playerModelWidth = 0.8;
        const playerGroundY = 0;
        let playerBoundingBox = new THREE.Box3();

        // --- Physics (Player) ---
        const gravity = 20.0;
        const jumpStrength = 8.0;
        let playerVelocityY = 0;
        let isGrounded = true;

        // --- Physics (Car) ---
        let carSpeed = 0;
        const carBaseMaxSpeed = 100;
        const carMaxReverseSpeed = -15;
        const carBaseAcceleration = 15;
        const carDeceleration = 20;
        const carBrakeDeceleration = 35;
        const carBaseTurnSpeed = Math.PI * 0.8;
        const carTurnSpeedFactor = 0.5;
        let carBoundingBox = new THREE.Box3();
        let isDrifting = false;
        const driftTurnMultiplier = 1.8;
        const driftTiltAngle = Math.PI / 18;
        let currentCarTilt = 0;
        const tiltSpeed = Math.PI / 4;

        // --- Physics (Plane) ---
        let planeSpeed = 0;
        // Scaled up speeds for deltaTime usage (FlightSim was per-frame)
        const planeBaseSpeed = 120.0;
        const planeMaxSpeed = 280.0;
        const planeMinSpeed = 60.0;

        // --- Vehicle Shared (Nitro/Boost) ---
        let isBoosting = false;
        const maxNitroAmount = 100;
        let nitroAmount = maxNitroAmount;
        const nitroConsumptionRate = 25;
        const nitroRechargeRate = 8;

        // Car Boost Multipliers
        const nitroAccelerationMultiplier = 3.0;
        const nitroMaxSpeedMultiplier = 1.6;
        const nitroTurnReduction = 0.4;

        // Camera FOV effects
        const baseCameraFOV = 75;
        const boostCameraFOV = 85;
        let currentCameraFOV = baseCameraFOV;
        const fovChangeSpeed = 30;

        // --- Targeting ---
        let currentTarget = null;
        const targetHighlightColor = 0x00ff00;

        // --- UI References ---
        let playerHpLabel, combatLogElement, gameOverScreen, abilityBarElement;
        let speedometerElement, nitroUiElement, nitroBarElement, interactionPromptElement, flightControlsInfo;
        let abilityButtons = [];

        // --- Input ---
        const moveSpeed = 5.0;
        const keysPressed = { w: false, a: false, s: false, d: false, space: false, shift: false, e: false };

        // --- Camera Control ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraTarget = new THREE.Vector3();
        let rpgCameraPhi = Math.PI / 4;
        let rpgCameraTheta = 0;
        const rpgCameraRadius = 15;
        const rpgCameraSensitivity = 0.005;
        const carCameraOffset = new THREE.Vector3(0, 8, -15);

        // --- Combat & AI Constants ---
        const attackRange = 15;
        const globalCooldownDuration = 1000;
        let globalCooldownEndTime = 0;
        const enemyCollisionDamage = 5;
        const enemyDamageCooldown = 1000;
        const frostNovaRadius = 5;
        const frostNovaDamage = 30;
        const immunityDuration = 5000;
        const enemyMoveSpeed = moveSpeed * 0.8;
        const enemyAggroRadius = 30;
        const enemyCollisionRadius = 1.5;
        const vehicleCollisionRadius = 2.0;

        // --- World ---
        const worldSize = 500;
        const fogNear = worldSize * 0.1;
        const fogFar = worldSize * 0.6;
        const roadWidth = 10;
        const roadSegments = 10;
        const roadSpacing = worldSize / roadSegments;

        // --- Interaction ---
        const interactionRadius = 5.0;

        // --- Init ---
        function init() {
            // UI Setup
            playerHpLabel = document.getElementById('player-hp-label');
            combatLogElement = document.getElementById('combat-log');
            gameOverScreen = document.getElementById('game-over');
            abilityBarElement = document.getElementById('ability-bar');
            speedometerElement = document.getElementById('speedometer');
            nitroUiElement = document.getElementById('nitro-ui');
            nitroBarElement = document.getElementById('nitro-bar');
            interactionPromptElement = document.getElementById('interaction-prompt');
            flightControlsInfo = document.getElementById('flight-controls');
            for (let i = 1; i <= 5; i++) {
                abilityButtons.push(document.getElementById(`ability-${i}`));
            }

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x5080a0);
            scene.fog = new THREE.Fog(0x5080a0, fogNear, fogFar);

            camera = new THREE.PerspectiveCamera(baseCameraFOV, window.innerWidth / window.innerHeight, 0.1, 2000); // Increased Far clip for flight

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Scene Objects
            setupLighting();
            setupGround();
            createRoadGrid();
            setupEnvironment();
            setupPlayer();
            setupCar();
            setupPlane(); // NEW
            setupEnemies();

            setupEventListeners();
            setCameraMode('onFoot');
            updateHpLabels();
            logCombatMessage("Welcome! Use 'E' to enter Car or Plane.");
            updateUIState();
            animate();
        }

        // --- Setup Functions ---
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(50, 100, 75);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 10;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -worldSize / 2;
            directionalLight.shadow.camera.right = worldSize / 2;
            directionalLight.shadow.camera.top = worldSize / 2;
            directionalLight.shadow.camera.bottom = -worldSize / 2;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
        }

        function setupGround() {
            const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x6B8E23, roughness: 0.9, metalness: 0.1 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.position.y = -0.01;
            scene.add(ground);
        }

        function setupPlayer() {
            player = createPlayerModel();
            player.position.set(0, playerGroundY, 0);
            player.castShadow = true;
            player.userData = { hpLabel: playerHpLabel, hpOffsetY: playerModelHeight + 0.3 };
            scene.add(player);
            playerBoundingBox.setFromObject(player);
        }

        function createRoadGrid() { /* Same as before */
            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 });
            const markingMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const markingGeometry = new THREE.BoxGeometry(0.2, 0.02, 2);
            const markingSpacing = 5;
            for (let i = 0; i <= roadSegments; i++) {
                const positionOffset = -worldSize / 2 + i * roadSpacing;
                const vRoadGeometry = new THREE.PlaneGeometry(roadWidth, worldSize);
                const vRoad = new THREE.Mesh(vRoadGeometry, roadMaterial);
                vRoad.rotation.x = -Math.PI / 2;
                vRoad.position.set(positionOffset, 0.01, 0);
                vRoad.receiveShadow = true;
                scene.add(vRoad);
                const hRoadGeometry = new THREE.PlaneGeometry(worldSize, roadWidth);
                const hRoad = new THREE.Mesh(hRoadGeometry, roadMaterial);
                hRoad.rotation.x = -Math.PI / 2;
                hRoad.position.set(0, 0.01, positionOffset);
                hRoad.receiveShadow = true;
                scene.add(hRoad);
                if (i > 0 && i < roadSegments) {
                    for (let z = -worldSize / 2 + markingSpacing / 2; z < worldSize / 2; z += markingSpacing) {
                        const vMarking = new THREE.Mesh(markingGeometry, markingMaterial);
                        vMarking.position.set(positionOffset, 0.02, z);
                        vMarking.receiveShadow = true;
                        scene.add(vMarking);
                    }
                }
                if (i > 0 && i < roadSegments) {
                    for (let x = -worldSize / 2 + markingSpacing / 2; x < worldSize / 2; x += markingSpacing) {
                        const hMarking = new THREE.Mesh(markingGeometry, markingMaterial);
                        hMarking.rotation.y = Math.PI / 2;
                        hMarking.position.set(x, 0.02, positionOffset);
                        hMarking.receiveShadow = true;
                        scene.add(hMarking);
                    }
                }
            }
        }

        function setupEnvironment() { /* Same as before */
            const treeCount = 100; const buildingCount = 20; const halfWorld = worldSize / 2; const halfRoadWidth = roadWidth / 2; const blockInnerSize = roadSpacing - roadWidth; environmentBoundingBoxes = []; environmentObjects = [];
            function isOnRoad(x, z) {
                for (let i = 0; i <= roadSegments; i++) {
                    const roadCenter = -halfWorld + i * roadSpacing;
                    if (Math.abs(x - roadCenter) < halfRoadWidth || Math.abs(z - roadCenter) < halfRoadWidth) return true;
                } return false;
            }
            for (let i = 0; i < treeCount; i++) {
                let placed = false;
                while (!placed) {
                    const blockX = Math.floor(Math.random() * roadSegments); const blockZ = Math.floor(Math.random() * roadSegments);
                    const blockCenterX = -halfWorld + blockX * roadSpacing + roadSpacing / 2; const blockCenterZ = -halfWorld + blockZ * roadSpacing + roadSpacing / 2;
                    const x = blockCenterX + (Math.random() - 0.5) * blockInnerSize; const z = blockCenterZ + (Math.random() - 0.5) * blockInnerSize;
                    if (!isOnRoad(x, z)) { const tree = createTree(new THREE.Vector3(x, 0, z)); scene.add(tree); environmentObjects.push(tree); placed = true; }
                }
            }
            for (let i = 0; i < buildingCount; i++) {
                let placed = false;
                while (!placed) {
                    const blockX = Math.floor(Math.random() * roadSegments); const blockZ = Math.floor(Math.random() * roadSegments);
                    const blockCenterX = -halfWorld + blockX * roadSpacing + roadSpacing / 2; const blockCenterZ = -halfWorld + blockZ * roadSpacing + roadSpacing / 2;
                    const x = blockCenterX + (Math.random() - 0.5) * blockInnerSize; const z = blockCenterZ + (Math.random() - 0.5) * blockInnerSize;
                    if (!isOnRoad(x, z)) {
                        const size = new THREE.Vector3(THREE.MathUtils.randFloat(5, 15), THREE.MathUtils.randFloat(8, 25), THREE.MathUtils.randFloat(5, 15));
                        const building = createBuilding(new THREE.Vector3(x, size.y / 2, z), size);
                        scene.add(building); environmentObjects.push(building);
                        const box = new THREE.Box3().setFromObject(building); box.expandByScalar(0.1); environmentBoundingBoxes.push(box); placed = true;
                    }
                }
            }
        }

        function createTree(position) {
            const trunkHeight = THREE.MathUtils.randFloat(3, 6); const trunkRadius = trunkHeight * 0.1;
            const foliageHeight = trunkHeight * THREE.MathUtils.randFloat(1.5, 2.5); const foliageRadius = trunkHeight * THREE.MathUtils.randFloat(0.6, 1.0);
            const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.7, trunkRadius, trunkHeight, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat); trunk.castShadow = true; trunk.receiveShadow = true;
            const foliageGeo = new THREE.ConeGeometry(foliageRadius, foliageHeight, 12);
            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const foliage = new THREE.Mesh(foliageGeo, foliageMat); foliage.castShadow = true; foliage.receiveShadow = true;
            const treeGroup = new THREE.Group(); treeGroup.add(trunk); treeGroup.add(foliage);
            treeGroup.position.copy(position); trunk.position.set(0, trunkHeight / 2, 0); foliage.position.set(0, trunkHeight + foliageHeight * 0.4, 0);
            return treeGroup;
        }

        function createBuilding(position, size) {
            const buildingGeo = new THREE.BoxGeometry(size.x, size.y, size.z);
            const greyShade = THREE.MathUtils.randFloat(0.3, 0.7);
            const buildingMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(greyShade, greyShade, greyShade), roughness: 0.8 });
            const building = new THREE.Mesh(buildingGeo, buildingMat);
            building.position.copy(position); building.castShadow = true; building.receiveShadow = true;
            return building;
        }

        function setupCar() {
            car = new THREE.Group(); car.position.set(5, 0.5, 5); car.rotation.y = -Math.PI / 4;
            const bodyGeometry = new THREE.BoxGeometry(2, 1, 4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0.3 });
            carBodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial); carBodyMesh.castShadow = true; carBodyMesh.receiveShadow = true;
            car.add(carBodyMesh);
            const cabinGeometry = new THREE.BoxGeometry(1.8, 0.8, 2);
            const cabinMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.6, metalness: 0.2 });
            const carCabin = new THREE.Mesh(cabinGeometry, cabinMaterial); carCabin.position.set(0, 0.9, -0.5); carCabin.castShadow = true; carCabin.receiveShadow = true; carBodyMesh.add(carCabin);
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.5, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
            const wheelPositions = [{ x: 1.1, y: -0.1, z: 1.3 }, { x: -1.1, y: -0.1, z: 1.3 }, { x: 1.1, y: -0.1, z: -1.3 }, { x: -1.1, y: -0.1, z: -1.3 }];
            wheelPositions.forEach(pos => { const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial); wheel.position.set(pos.x, pos.y, pos.z); wheel.rotation.z = Math.PI / 2; wheel.castShadow = true; car.add(wheel); });
            scene.add(car); carBoundingBox.setFromObject(car);
        }

        // --- NEW: Plane Setup (From Flight Sim) ---
        function setupPlane() {
            plane = new THREE.Group();

            // Materials
            const redMat = new THREE.MeshStandardMaterial({ color: 0xd9534f, flatShading: true });
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xf7f7f7, flatShading: true });
            const greyMat = new THREE.MeshStandardMaterial({ color: 0x333333, flatShading: true });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB, opacity: 0.7, transparent: true });

            // Fuselage
            const fuselageGeo = new THREE.BoxGeometry(1.5, 1.5, 8);
            const posAttr = fuselageGeo.attributes.position;
            for (let i = 0; i < posAttr.count; i++) {
                const z = posAttr.getZ(i);
                if (z < -2) { // Taper front
                    const scale = 0.7;
                    posAttr.setX(i, posAttr.getX(i) * scale);
                    posAttr.setY(i, posAttr.getY(i) * scale);
                }
            }
            fuselageGeo.computeVertexNormals();
            const fuselage = new THREE.Mesh(fuselageGeo, whiteMat);
            fuselage.castShadow = true; fuselage.receiveShadow = true;
            plane.add(fuselage);

            // Cockpit
            const cockpit = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 2.5), glassMat);
            cockpit.position.set(0, 0.8, -1);
            plane.add(cockpit);

            // Wings
            const wing = new THREE.Mesh(new THREE.BoxGeometry(12, 0.2, 3), redMat);
            wing.position.set(0, 0, 0.5); wing.castShadow = true;
            plane.add(wing);

            // Tails
            const tailV = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2.5, 2), redMat);
            tailV.position.set(0, 1, 3.5); tailV.castShadow = true;
            plane.add(tailV);
            const tailH = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 1.5), redMat);
            tailH.position.set(0, 0.5, 3.5); tailH.castShadow = true;
            plane.add(tailH);

            // Propeller
            const spinner = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), redMat);
            spinner.position.set(0, 0, -4.1);
            plane.add(spinner);
            propeller = new THREE.Mesh(new THREE.BoxGeometry(5, 0.1, 0.3), greyMat);
            propeller.position.set(0, 0, -4.1);
            plane.add(propeller);

            // Initial Position (Parked near car)
            plane.position.set(15, 2, 5);
            plane.rotation.y = -Math.PI / 2;
            scene.add(plane);
        }

        function createPlayerModel() {
            const playerGroup = new THREE.Group();
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const torsoMat = new THREE.MeshStandardMaterial({ color: 0x0000ff });
            const limbMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), headMat); head.castShadow = true;
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.8, 0.4), torsoMat); torso.castShadow = true;
            const limbGeo = new THREE.BoxGeometry(0.25, 0.8, 0.25);
            const leftLeg = new THREE.Mesh(limbGeo, limbMat); leftLeg.castShadow = true;
            const rightLeg = new THREE.Mesh(limbGeo, limbMat); rightLeg.castShadow = true;
            head.position.set(0, 1.45, 0); torso.position.set(0, 0.8, 0);
            leftLeg.position.set(-0.225, 0.4, 0); rightLeg.position.set(0.225, 0.4, 0);
            playerGroup.add(head, torso, leftLeg, rightLeg);
            return playerGroup;
        }

        function setupEnemies() {
            const enemyPositions = [{ x: 10, y: 0, z: -8 }, { x: -12, y: 0, z: -15 }, { x: 15, y: 0, z: 5 }, { x: -8, y: 0, z: 18 }, { x: 20, y: 0, z: -20 }];
            const enemyMaxHP = 50;
            enemyBoundingBoxes = []; enemies = [];
            enemyPositions.forEach((pos, index) => {
                const enemy = createEnemy(pos, enemyMaxHP, index);
                scene.add(enemy); enemies.push(enemy);
                enemyBoundingBoxes.push(new THREE.Box3().setFromObject(enemy));
            });
        }

        function createEnemy(position, maxHP, index) {
            // Wolf-like placeholder
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 1.4), new THREE.MeshStandardMaterial({ color: 0x665a48 }));
            body.position.y = 0.6; group.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: 0x665a48 }));
            head.position.set(0, 1.0, 0.8); group.add(head);
            group.position.copy(position); group.castShadow = true;

            const label = document.createElement('div'); label.className = 'hp-label'; document.body.appendChild(label);
            group.userData = { id: `Wolf ${index}`, hpLabel: label, hpOffsetY: 1.2, maxHP, currentHP: maxHP, isDead: false, baseMaterials: {}, lastDamageTime: 0 };
            group.traverse(c => { if (c.isMesh) { group.userData.baseMaterials[c.uuid] = c.material; c.castShadow = true; } });
            return group;
        }

        // --- Event Listeners ---
        function setupEventListeners() {
            window.addEventListener("resize", () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            window.addEventListener("keydown", onKeyDown);
            window.addEventListener("keyup", onKeyUp);
            renderer.domElement.addEventListener("mousedown", onMouseDown);
            window.addEventListener("mousemove", onMouseMove);
            window.addEventListener("mouseup", onMouseUp);
            abilityButtons.forEach((btn, i) => btn.addEventListener('click', () => useAbility(i + 1)));
        }

        function onKeyDown(event) {
            const k = event.key.toLowerCase();
            if (k === 'shift') keysPressed.shift = true;
            else if (event.code === 'Space') keysPressed.space = true;
            else if (k === 'e') { keysPressed.e = true; handleInteraction(); }
            else if (k in keysPressed) keysPressed[k] = true;

            if (playerState === 'onFoot' && !isPlayerDead) {
                if (['1', '2', '3', '4', '5'].includes(k)) useAbility(parseInt(k));
                if (event.code === 'Space' && isGrounded) { playerVelocityY = jumpStrength; isGrounded = false; }
            }
        }

        function onKeyUp(event) {
            const k = event.key.toLowerCase();
            if (k === 'shift') keysPressed.shift = false;
            else if (event.code === 'Space') keysPressed.space = false;
            else if (k === 'e') keysPressed.e = false;
            else if (k in keysPressed) keysPressed[k] = false;
        }

        function onMouseDown(event) {
            if (playerState === 'onFoot' && !isPlayerDead) {
                mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(enemies, true);
                if (intersects.length > 0) {
                    let g = intersects[0].object; while (g.parent !== scene) g = g.parent;
                    if (g.userData && !g.userData.isDead) setTarget(g);
                }
            }
            if (!isPlayerDead && event.button === 0) {
                isDragging = true; previousMousePosition.x = event.clientX; previousMousePosition.y = event.clientY;
                renderer.domElement.style.cursor = 'grabbing';
            }
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                if (playerState === 'onFoot') {
                    rpgCameraTheta -= deltaX * rpgCameraSensitivity;
                    rpgCameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, rpgCameraPhi - deltaY * rpgCameraSensitivity));
                }
                previousMousePosition.x = event.clientX; previousMousePosition.y = event.clientY;
            }
        }
        function onMouseUp() { isDragging = false; renderer.domElement.style.cursor = 'crosshair'; }

        // --- Interaction System ---
        function handleInteraction() {
            if (isPlayerDead) return;

            if (playerState === 'onFoot') {
                const distCar = player.position.distanceTo(car.position);
                const distPlane = player.position.distanceTo(plane.position);

                if (distPlane < interactionRadius) {
                    enterPlane();
                } else if (distCar < interactionRadius) {
                    enterCar();
                }
            } else if (playerState === 'inCar') {
                exitCar();
            } else if (playerState === 'inPlane') {
                exitPlane();
            }
        }

        function enterCar() {
            playerState = 'inCar'; player.visible = false;
            carSpeed = 0; isDrifting = false; isBoosting = false;
            if (carBodyMesh) carBodyMesh.rotation.z = 0;
            setCameraMode('inCar'); updateUIState(); setTarget(null);
        }

        function exitCar() {
            playerState = 'onFoot';
            const offset = new THREE.Vector3(2, 0, 0).applyQuaternion(car.quaternion);
            player.position.copy(car.position).add(offset); player.position.y = playerGroundY;
            player.visible = true; isGrounded = true; playerVelocityY = 0;
            setCameraMode('onFoot'); updateUIState();
        }

        function enterPlane() {
            playerState = 'inPlane'; player.visible = false;
            planeSpeed = 0; isBoosting = false;
            setCameraMode('inPlane'); updateUIState(); setTarget(null);
        }

        function exitPlane() {
            // Prevent exit if flying high
            if (plane.position.y > 5) {
                logCombatMessage("Too high to exit!");
                return;
            }
            playerState = 'onFoot';
            const offset = new THREE.Vector3(2, 0, 0).applyQuaternion(plane.quaternion);
            player.position.copy(plane.position).add(offset);
            player.position.y = playerGroundY;
            player.visible = true; isGrounded = true;
            // Level the plane out on exit
            plane.rotation.z = 0; plane.rotation.x = 0;
            setCameraMode('onFoot'); updateUIState();
        }

        function updateUIState() {
            const isVehicle = (playerState === 'inCar' || playerState === 'inPlane');
            speedometerElement.style.display = isVehicle ? 'block' : 'none';
            nitroUiElement.style.display = isVehicle ? 'block' : 'none';
            flightControlsInfo.style.display = (playerState === 'inPlane') ? 'block' : 'none';
            abilityBarElement.style.display = isVehicle ? 'none' : 'flex';
            combatLogElement.style.display = isVehicle ? 'none' : 'flex';
        }

        // --- Logic Updates ---
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const currentTime = performance.now();

            if (playerState === 'onFoot') updatePlayerPhysics(deltaTime);
            else if (playerState === 'inCar') updateCarPhysics(deltaTime);
            else if (playerState === 'inPlane') updatePlanePhysics(deltaTime);

            updateEnemyAI(deltaTime, currentTime);
            updateCamera(deltaTime);

            // UI
            if (playerState === 'inPlane') speedometerElement.innerText = `Airspeed: ${Math.round(planeSpeed)}`;
            else if (playerState === 'inCar') speedometerElement.innerText = `Speed: ${Math.round(carSpeed)}`;

            // Nitro UI
            if (playerState !== 'onFoot') {
                const p = (nitroAmount / maxNitroAmount) * 100;
                nitroBarElement.style.width = `${p}%`;
            }

            updateInteractionPrompt();
            updateHpLabels();
            renderer.render(scene, camera);
        }

        function updatePlayerPhysics(dt) {
            if (isPlayerDead) return;
            const moveDir = new THREE.Vector3(0, 0, 0);
            if (keysPressed.w) moveDir.z = -1; if (keysPressed.s) moveDir.z = 1;
            if (keysPressed.a) moveDir.x = -1; if (keysPressed.d) moveDir.x = 1;

            if (moveDir.lengthSq() > 0) {
                moveDir.normalize();
                const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); camDir.y = 0; camDir.normalize();
                const camLeft = new THREE.Vector3().crossVectors(camera.up, camDir).normalize();
                const finalMove = new THREE.Vector3().addScaledVector(camDir, -moveDir.z).addScaledVector(camLeft, -moveDir.x).normalize();

                let moveAmt = moveSpeed * dt;
                const nextPos = player.position.clone().addScaledVector(finalMove, moveAmt);
                playerBoundingBox.setFromCenterAndSize(nextPos.setY(playerModelHeight / 2), new THREE.Vector3(playerModelWidth, playerModelHeight, playerModelWidth));

                if (!environmentBoundingBoxes.some(b => playerBoundingBox.intersectsBox(b))) {
                    player.position.addScaledVector(finalMove, moveAmt);
                    const qt = new THREE.Quaternion().setFromRotationMatrix(new THREE.Matrix4().lookAt(player.position, player.position.clone().add(finalMove), player.up));
                    player.quaternion.slerp(qt, 0.15);
                }
            }
            playerVelocityY -= gravity * dt; player.position.y += playerVelocityY * dt;
            if (player.position.y <= playerGroundY) { player.position.y = playerGroundY; playerVelocityY = 0; isGrounded = true; } else isGrounded = false;
        }

        function updateCarPhysics(dt) {
            // Nitro Logic
            if (!isBoosting && nitroAmount < maxNitroAmount) nitroAmount = Math.min(maxNitroAmount, nitroAmount + nitroRechargeRate * dt);
            if (keysPressed.shift && nitroAmount > 0) { isBoosting = true; nitroAmount = Math.max(0, nitroAmount - nitroConsumptionRate * dt); }
            else isBoosting = false;

            // Drift
            isDrifting = keysPressed.space && carSpeed > 30 && !isBoosting;

            // Acceleration
            let acc = carBaseAcceleration; let maxS = carBaseMaxSpeed; let turnS = carBaseTurnSpeed;
            if (isBoosting) { acc *= nitroAccelerationMultiplier; maxS *= nitroMaxSpeedMultiplier; turnS *= nitroTurnReduction; }

            if (keysPressed.w) carSpeed += acc * dt;
            else if (keysPressed.s) carSpeed -= (carSpeed > 1 ? carBrakeDeceleration : carBaseAcceleration) * dt;
            else carSpeed -= Math.sign(carSpeed) * carDeceleration * dt;

            if (Math.abs(carSpeed) < 1 && !keysPressed.w && !keysPressed.s) carSpeed = 0;
            carSpeed = Math.max(carMaxReverseSpeed, Math.min(maxS, carSpeed));

            // Turning
            if (Math.abs(carSpeed) > 1) {
                let turnDir = (keysPressed.a ? 1 : 0) + (keysPressed.d ? -1 : 0);
                car.rotation.y += turnS * turnDir * dt * (isDrifting ? driftTurnMultiplier : 1);

                // Visual Tilt
                const targetTilt = isDrifting ? (keysPressed.a ? driftTiltAngle : -driftTiltAngle) : 0;
                currentCarTilt += (targetTilt - currentCarTilt) * Math.min(1, tiltSpeed * dt);
                carBodyMesh.rotation.z = currentCarTilt;
            }

            // Movement
            const fwd = new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion);
            const moveVec = fwd.multiplyScalar(carSpeed * dt);

            carBoundingBox.setFromObject(car).translate(moveVec);
            if (!environmentBoundingBoxes.some(b => carBoundingBox.intersectsBox(b))) {
                car.position.add(moveVec);
            } else {
                carSpeed = -carSpeed * 0.5; // Bounce
            }
        }

        // --- NEW: Plane Physics (Ported from Flight Sim) ---
        function updatePlanePhysics(dt) {
            // 1. Speed Logic
            let targetSpeed = planeBaseSpeed;

            // Turbo (Shift)
            if (keysPressed.shift && nitroAmount > 0) {
                targetSpeed = planeMaxSpeed;
                isBoosting = true;
                nitroAmount = Math.max(0, nitroAmount - nitroConsumptionRate * dt);
            } else {
                isBoosting = false;
                if (nitroAmount < maxNitroAmount) nitroAmount += nitroRechargeRate * dt;
            }

            // Brake/Slow (Space)
            if (keysPressed.space) targetSpeed = planeMinSpeed;

            // Smooth acceleration
            planeSpeed += (targetSpeed - planeSpeed) * 2.0 * dt;

            // 2. Rotation (Pitch & Roll)
            const pitchSpeed = 1.5 * dt;
            const rollSpeed = 2.0 * dt;

            // Pitch (W = Down, S = Up) - Flight controls
            if (keysPressed.w) plane.rotateX(pitchSpeed);
            if (keysPressed.s) plane.rotateX(-pitchSpeed);

            // Roll (A = Left, D = Right)
            if (keysPressed.a) {
                plane.rotateZ(rollSpeed);
                plane.rotateY(0.5 * dt); // Yaw into turn
            }
            if (keysPressed.d) {
                plane.rotateZ(-rollSpeed);
                plane.rotateY(-0.5 * dt);
            }

            // 3. Movement (Always move forward along local Z negative)
            plane.translateZ(-planeSpeed * dt);

            // 4. Propeller Animation
            if (propeller) propeller.rotation.z += 10 + (planeSpeed * 0.1);

            // 5. Ground Collision
            if (plane.position.y < 2) {
                plane.position.y = 2;
                // Level out slightly on ground hit
                plane.rotation.x *= 0.9;
                plane.rotation.z *= 0.9;
            }
        }

        function updateEnemyAI(dt, time) {
            // Update boxes
            enemies.forEach((e, i) => { if (!e.userData.isDead) enemyBoundingBoxes[i].setFromObject(e); });

            const targetObj = (playerState === 'inCar') ? car : (playerState === 'inPlane' ? plane : player);
            // If in plane and high up, enemies lose aggro effectively
            if (playerState === 'inPlane' && plane.position.y > 10) return;

            const targetPos = targetObj.position;
            const colRad = (playerState === 'onFoot') ? enemyCollisionRadius : vehicleCollisionRadius;

            enemies.forEach((enemy, i) => {
                if (enemy.userData.isDead || isPlayerDead) return;

                const distSq = targetPos.distanceToSquared(enemy.position);

                // Move if close enough but not colliding
                if (distSq < enemyAggroRadius ** 2) {
                    if (distSq > colRad ** 2 * 1.1) {
                        const dir = new THREE.Vector3().subVectors(targetPos, enemy.position);
                        dir.y = 0; dir.normalize();

                        const moveAmt = enemyMoveSpeed * dt;
                        const potentialPos = enemy.position.clone().addScaledVector(dir, moveAmt);
                        const potentialBox = enemyBoundingBoxes[i].clone().translate(dir.clone().multiplyScalar(moveAmt));

                        // Avoid other enemies
                        let blocked = false;
                        for (let j = 0; j < enemies.length; j++) {
                            if (i !== j && !enemies[j].userData.isDead && potentialBox.intersectsBox(enemyBoundingBoxes[j])) {
                                // Check if moving towards them
                                const toOther = new THREE.Vector3().subVectors(enemies[j].position, enemy.position).normalize();
                                if (dir.dot(toOther) > 0.1) { blocked = true; break; }
                            }
                        }

                        if (!blocked) {
                            enemy.position.addScaledVector(dir, moveAmt);
                            const qt = new THREE.Quaternion().setFromRotationMatrix(new THREE.Matrix4().lookAt(enemy.position, enemy.position.clone().add(dir), enemy.up));
                            enemy.quaternion.slerp(qt, 0.1);
                        }
                    }

                    // Damage Player
                    if (distSq < colRad ** 2 && time > enemy.userData.lastDamageTime + enemyDamageCooldown) {
                        // Don't damage car/plane as easily? For now, same damage logic
                        applyDamage(player, enemyCollisionDamage, enemy.userData.id);
                        enemy.userData.lastDamageTime = time;
                        flashObject(playerState === 'onFoot' ? player : (playerState === 'inCar' ? car : plane), 0xff0000);
                        updateHpLabels();
                    }
                }
            });
        }

        function updateCamera(dt) {
            if (playerState === 'onFoot') {
                cameraTarget.copy(player.position).y += playerModelHeight * 0.6;
                const x = cameraTarget.x + rpgCameraRadius * Math.sin(rpgCameraPhi) * Math.sin(rpgCameraTheta);
                const y = cameraTarget.y + rpgCameraRadius * Math.cos(rpgCameraPhi);
                const z = cameraTarget.z + rpgCameraRadius * Math.sin(rpgCameraPhi) * Math.cos(rpgCameraTheta);
                camera.position.set(x, y, z);
                camera.lookAt(cameraTarget);
                currentCameraFOV = baseCameraFOV;
            } else if (playerState === 'inCar') {
                // Car Camera (Rigid Follow with FOV zoom)
                let targetFOV = isBoosting ? boostCameraFOV : baseCameraFOV;
                currentCameraFOV += (targetFOV - currentCameraFOV) * Math.min(1, fovChangeSpeed * dt);
                camera.fov = currentCameraFOV; camera.updateProjectionMatrix();

                const targetPos = new THREE.Vector3().copy(carCameraOffset).applyQuaternion(car.quaternion).add(car.position);
                camera.position.lerp(targetPos, 0.1);
                const lookAtPos = car.position.clone().addScaledVector(new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion), 5).setY(car.position.y + 1);
                camera.lookAt(lookAtPos);
            } else if (playerState === 'inPlane') {
                // Plane Camera (Loose Follow - from Flight Sim)
                const idealOffset = new THREE.Vector3(0, 6, 18).applyMatrix4(plane.matrixWorld);
                const idealLook = new THREE.Vector3(0, 0, -20).applyMatrix4(plane.matrixWorld);

                camera.position.lerp(idealOffset, 0.05); // Softer lerp for flying
                camera.lookAt(idealLook);

                let targetFOV = isBoosting ? 90 : 75;
                camera.fov = THREE.MathUtils.lerp(camera.fov, targetFOV, 0.05);
                camera.updateProjectionMatrix();
            }
        }

        function setCameraMode(mode) {
            if (mode === 'inCar') {
                camera.position.copy(car.position).add(new THREE.Vector3(0, 10, -10));
            } else if (mode === 'inPlane') {
                camera.position.copy(plane.position).add(new THREE.Vector3(0, 10, 20));
            } else {
                camera.fov = baseCameraFOV; camera.updateProjectionMatrix();
            }
        }

        function updateInteractionPrompt() {
            interactionPromptElement.style.display = 'none';
            if (isPlayerDead) return;

            if (playerState === 'onFoot') {
                const dCar = player.position.distanceTo(car.position);
                const dPlane = player.position.distanceTo(plane.position);
                if (dCar < interactionRadius) {
                    interactionPromptElement.style.display = 'block';
                    interactionPromptElement.innerText = 'Press [E] to Drive Car';
                } else if (dPlane < interactionRadius) {
                    interactionPromptElement.style.display = 'block';
                    interactionPromptElement.innerText = 'Press [E] to Fly Plane';
                }
            } else if (playerState === 'inCar') {
                interactionPromptElement.style.display = 'block';
                interactionPromptElement.innerText = 'Press [E] to Exit Car';
            } else if (playerState === 'inPlane') {
                // Only show exit prompt if near ground
                if (plane.position.y < 5) {
                    interactionPromptElement.style.display = 'block';
                    interactionPromptElement.innerText = 'Press [E] to Exit Plane';
                }
            }
        }

        // --- Combat Utils ---
        function setTarget(t) {
            if (currentTarget && currentTarget !== t) {
                if (!currentTarget.userData.isDead) currentTarget.traverse(c => { if (c.isMesh && currentTarget.userData.baseMaterials[c.uuid]) c.material = currentTarget.userData.baseMaterials[c.uuid]; });
            }
            currentTarget = t;
            if (currentTarget) {
                currentTarget.traverse(c => { if (c.isMesh && c.material.emissive) c.material.emissive.setHex(targetHighlightColor); });
                logCombatMessage(`Targeted ${currentTarget.userData.id}`);
            }
        }

        function useAbility(id) {
            if (playerState !== 'onFoot' || isPlayerDead) return;
            if (performance.now() < globalCooldownEndTime) { logCombatMessage("Cooldown..."); return; }

            const t = currentTarget;
            if ([1, 3, 4].includes(id) && (!t || t.userData.isDead)) { logCombatMessage("No Valid Target"); return; }
            if ([1, 3].includes(id) && player.position.distanceTo(t.position) > attackRange) { logCombatMessage("Out of Range"); return; }

            let msg = "";
            if (id === 1) { applyDamage(t, 10); flashObject(t, 0xffff00); msg = "Melee Attack (10)"; }
            else if (id === 2) { isPlayerImmune = true; playerImmunityEndTime = performance.now() + immunityDuration; showImmunityVisual(true); msg = "Defend (Immune 5s)"; }
            else if (id === 3) { applyDamage(t, 15); flashObject(t, 0xff8c00); msg = "Fireball (15)"; }
            else if (id === 4) {
                createFrostAoe(t.position);
                enemies.forEach(e => { if (!e.userData.isDead && e.position.distanceTo(t.position) < frostNovaRadius) { applyDamage(e, 30); flashObject(e, 0x00ffff); } });
                msg = "Frost Nova (AOE 30)";
            }
            else if (id === 5) { let h = Math.min(20, playerMaxHP - playerCurrentHP); playerCurrentHP += h; flashObject(player, 0x00ff00); msg = `Heal (+${h})`; }

            logCombatMessage(msg); updateHpLabels();
            globalCooldownEndTime = performance.now() + globalCooldownDuration;
            updateCooldownVisual(performance.now());
        }

        function applyDamage(t, amt, src = "Hit") {
            if (!t || isPlayerDead) return;
            if (t === player) {
                if (isPlayerImmune) return;
                playerCurrentHP = Math.max(0, playerCurrentHP - amt);
                if (playerCurrentHP <= 0) handlePlayerDeath();
            } else {
                t.userData.currentHP = Math.max(0, t.userData.currentHP - amt);
                if (t.userData.currentHP <= 0) handleEnemyDeath(t);
            }
        }

        function handleEnemyDeath(e) {
            e.userData.isDead = true;
            e.traverse(c => { if (c.isMesh) c.material = new THREE.MeshStandardMaterial({ color: 0x555555 }); });
            if (currentTarget === e) setTarget(null);
            logCombatMessage(`${e.userData.id} Defeated`);
        }

        function handlePlayerDeath() {
            isPlayerDead = true;
            gameOverScreen.style.display = 'flex';
            player.traverse(c => { if (c.isMesh) c.material.color.set(0x555555); });
            if (playerState !== 'onFoot') { if (playerState === 'inCar') exitCar(); else exitPlane(); }
        }

        // --- Visuals ---
        function flashObject(obj, color) {
            if (!obj) return;
            const restore = (o, mat) => { setTimeout(() => { if (o && o.material) o.material = mat; }, 150); };
            obj.traverse(c => {
                if (c.isMesh && c.material) {
                    const clone = c.material.clone(); clone.emissive.setHex(color);
                    const orig = c.material; c.material = clone; restore(c, orig);
                }
            });
        }

        function createFrostAoe(pos) {
            const mesh = new THREE.Mesh(new THREE.RingGeometry(0.1, frostNovaRadius, 32), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, side: THREE.DoubleSide }));
            mesh.rotation.x = -Math.PI / 2; mesh.position.copy(pos).setY(0.1);
            scene.add(mesh); setTimeout(() => { scene.remove(mesh); }, 500);
        }

        function showImmunityVisual(show) {
            if (show) {
                if (!immunityVisual) { immunityVisual = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })); player.add(immunityVisual); }
                immunityVisual.visible = true;
            } else if (immunityVisual) immunityVisual.visible = false;
        }

        function updateHpLabels() {
            if (player && player.userData.hpLabel) player.userData.hpLabel.textContent = `HP: ${playerCurrentHP}/${playerMaxHP}`;
            enemies.forEach(e => {
                if (e.userData.hpLabel) {
                    e.userData.hpLabel.textContent = `${e.userData.id}: ${e.userData.currentHP}`;
                    const pos = e.position.clone().setY(e.position.y + e.userData.hpOffsetY).project(camera);
                    if (pos.z < 1) {
                        e.userData.hpLabel.style.left = `${(pos.x * .5 + .5) * window.innerWidth}px`;
                        e.userData.hpLabel.style.top = `${(-pos.y * .5 + .5) * window.innerHeight}px`;
                        e.userData.hpLabel.style.display = 'block';
                    } else e.userData.hpLabel.style.display = 'none';
                }
            });
            if (player.userData.hpLabel) { // Player label
                const pos = player.position.clone().setY(player.position.y + 2.2).project(camera);
                const lbl = player.userData.hpLabel;
                if (pos.z < 1 && player.visible) {
                    lbl.style.left = `${(pos.x * .5 + .5) * window.innerWidth}px`;
                    lbl.style.top = `${(-pos.y * .5 + .5) * window.innerHeight}px`;
                    lbl.style.display = 'block';
                } else lbl.style.display = 'none';
            }
        }

        function updateCooldownVisual(t) {
            const cd = t < globalCooldownEndTime;
            abilityButtons.forEach(b => cd ? b.classList.add('on-cooldown') : b.classList.remove('on-cooldown'));
            if (isPlayerImmune && t > playerImmunityEndTime) { isPlayerImmune = false; showImmunityVisual(false); }
        }

        function logCombatMessage(msg) {
            const p = document.createElement('p'); p.innerText = msg;
            combatLogElement.prepend(p);
            if (combatLogElement.children.length > 6) combatLogElement.lastChild.remove();
        }

        init();
    </script>
</body>

</html>