<!-- START OF FILE GTAJS.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Massive Open World RPG + Flight Sim</title>
    <style>
        /* Basic styling */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background-color: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        /* Info text container */
        .info-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
            max-width: 280px;
            pointer-events: none;
        }

        #ability-info {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        #ability-info h4 {
            margin: 0 0 5px 0;
            font-size: 1.1em;
            font-weight: bold;
        }

        #ability-info p {
            margin: 2px 0;
            font-size: 0.95em;
        }

        /* --- RPG UI --- */
        #ability-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
        }

        .ability-button {
            width: 50px;
            height: 50px;
            background-color: #333;
            border: 2px solid #555;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s, opacity 0.1s;
            position: relative;
        }

        .ability-button:hover {
            background-color: #444;
            border-color: #777;
        }

        .ability-button:active {
            background-color: #222;
            border-color: #444;
        }

        .keybind {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
        }

        .ability-text {
            font-size: 18px;
        }

        .ability-button.on-cooldown {
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed;
        }

        #combat-log {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 250px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: white;
            font-size: 12px;
            padding: 5px;
            overflow-y: scroll;
            z-index: 100;
            display: flex;
            flex-direction: column-reverse;
            pointer-events: none;
        }

        #combat-log p {
            margin: 1px 0;
            line-height: 1.2;
            text-shadow: 1px 1px 0 #000;
        }

        /* --- Vehicle UI --- */
        #speedometer {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 24px;
            font-weight: bold;
            z-index: 10;
            min-width: 120px;
            text-align: center;
            display: none;
            font-family: monospace;
        }

        #nitro-ui {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
            width: 150px;
            text-align: left;
            display: none;
        }

        #nitro-bar-container {
            width: 100%;
            height: 10px;
            background-color: #555;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 4px;
        }

        #nitro-bar {
            width: 100%;
            height: 100%;
            background-color: #00ccff;
            border-radius: 3px;
            transition: width 0.1s linear;
        }

        #altimeter {
            position: absolute;
            bottom: 50px;
            left: 10px;
            color: #aaa;
            font-family: monospace;
            font-size: 16px;
            display: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* --- General UI --- */
        .hp-label {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            transform: translateX(-50%);
            z-index: 99;
            display: none;
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: #ff4444;
            font-size: 48px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 300;
            display: none;
            cursor: default;
        }

        #interaction-prompt {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 101;
            display: none;
            white-space: nowrap;
        }

        #flight-controls {
            display: none;
            font-size: 0.9em;
            color: #aaa;
            margin-top: 5px;
            border-top: 1px solid #444;
            padding-top: 5px;
        }
    </style>
</head>

<body>
    <div class="info-container">
        <div id="movement-info">
            WASD: Move<br>
            Space: Jump/Drift/Brake<br>
            LShift: Nitro/Turbo<br>
            E: Enter/Exit Vehicle<br>
            Click: Target, Drag: Rotate
            <div id="flight-controls">
                <b>Plane Controls:</b><br>
                W/S: Pitch Down/Up<br>
                A/D: Roll Left/Right<br>
                Shift: Fast | Space: Slow
            </div>
        </div>
        <div id="ability-info">
            <h4>Abilities (On Foot):</h4>
            <p>1 (‚öîÔ∏è): Attack</p>
            <p>2 (üõ°Ô∏è): Defend</p>
            <p>3 (üî•): Fireball</p>
            <p>4 (‚ùÑÔ∏è): Frost Nova</p>
            <p>5 (‚ú®): Heal</p>
        </div>
    </div>

    <div id="player-hp-label" class="hp-label"></div>
    <div id="ability-bar">
        <button class="ability-button" id="ability-1"><span class="keybind">1</span><span
                class="ability-text">‚öîÔ∏è</span></button>
        <button class="ability-button" id="ability-2"><span class="keybind">2</span><span
                class="ability-text">üõ°Ô∏è</span></button>
        <button class="ability-button" id="ability-3"><span class="keybind">3</span><span
                class="ability-text">üî•</span></button>
        <button class="ability-button" id="ability-4"><span class="keybind">4</span><span
                class="ability-text">‚ùÑÔ∏è</span></button>
        <button class="ability-button" id="ability-5"><span class="keybind">5</span><span
                class="ability-text">‚ú®</span></button>
    </div>
    <div id="combat-log"></div>

    <div id="speedometer">Speed: 0</div>
    <div id="altimeter">Alt: 0</div>
    <div id="nitro-ui">
        Turbo/Nitro:
        <div id="nitro-bar-container">
            <div id="nitro-bar"></div>
        </div>
    </div>

    <div id="interaction-prompt">Press [E] to Enter</div>
    <div id="game-over">YOU DIED</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Core Three.js Variables ---
        let scene, camera, renderer;
        let clock = new THREE.Clock();
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let activeVisualEffects = [];

        // --- Game Objects ---
        let player;
        let car;
        let carBodyMesh;
        let plane;
        let propeller;
        let enemies = [];
        let enemyBoundingBoxes = [];

        // --- World Generation Constants ---
        const WORLD_SIZE = 5000; // Massive world
        const FOG_DIST = 1800;
        const BLOCK_SIZE = 120; // Size of a city block (including road)
        const ROAD_WIDTH = 25;
        const BUILDING_PADDING = 5;

        // Instanced Mesh References
        let buildingsInstancedMesh;
        let treesInstancedMesh;

        // --- Player State ---
        let playerState = 'onFoot'; // 'onFoot', 'inCar', 'inPlane'
        let playerMaxHP = 100;
        let playerCurrentHP = playerMaxHP;
        let isPlayerDead = false;
        let isPlayerImmune = false;
        let playerImmunityEndTime = 0;
        let immunityVisual = null;
        const playerModelHeight = 1.8;
        const playerModelWidth = 0.8;
        const playerGroundY = 0;
        let playerBoundingBox = new THREE.Box3();

        // --- Physics (Player) ---
        const gravity = 25.0;
        const jumpStrength = 10.0;
        let playerVelocityY = 0;
        let isGrounded = true;

        // --- Physics (Car) ---
        let carSpeed = 0;
        const carBaseMaxSpeed = 120;
        const carMaxReverseSpeed = -20;
        const carBaseAcceleration = 25;
        const carDeceleration = 15;
        const carBrakeDeceleration = 40;
        const carBaseTurnSpeed = Math.PI * 0.8;
        let carBoundingBox = new THREE.Box3();
        let isDrifting = false;
        const driftTurnMultiplier = 1.8;
        const driftTiltAngle = Math.PI / 18;
        let currentCarTilt = 0;
        const tiltSpeed = Math.PI / 4;

        // --- Physics (Plane) ---
        let planeSpeed = 0;
        const planeBaseSpeed = 150.0;
        const planeMaxSpeed = 350.0;
        const planeMinSpeed = 60.0;

        // --- Vehicle Shared (Nitro/Boost) ---
        let isBoosting = false;
        const maxNitroAmount = 100;
        let nitroAmount = maxNitroAmount;
        const nitroConsumptionRate = 25;
        const nitroRechargeRate = 8;

        const nitroAccelerationMultiplier = 3.0;
        const nitroMaxSpeedMultiplier = 1.6;
        const nitroTurnReduction = 0.4;

        // Camera
        const baseCameraFOV = 75;
        const boostCameraFOV = 90;
        let currentCameraFOV = baseCameraFOV;
        const fovChangeSpeed = 30;

        // --- Targeting ---
        let currentTarget = null;
        const targetHighlightColor = 0x00ff00;

        // --- UI References ---
        let playerHpLabel, combatLogElement, gameOverScreen, abilityBarElement;
        let speedometerElement, altimeterElement, nitroUiElement, nitroBarElement, interactionPromptElement, flightControlsInfo;
        let abilityButtons = [];

        // --- Input ---
        const moveSpeed = 10.0; // Faster running for big world
        const keysPressed = { w: false, a: false, s: false, d: false, space: false, shift: false, e: false };

        // --- Camera Control ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraTarget = new THREE.Vector3();
        // RPG Camera (On Foot)
        let rpgCameraPhi = Math.PI / 4;
        let rpgCameraTheta = 0;
        const rpgCameraRadius = 15;
        const rpgCameraSensitivity = 0.005;
        // Vehicle Camera (Car/Plane)
        let vehicleLookX = 0; // Left/Right deviation
        let vehicleLookY = 0; // Up/Down deviation
        const carCameraOffset = new THREE.Vector3(0, 8, -15);

        // --- Combat & AI Constants ---
        const attackRange = 25;
        const globalCooldownDuration = 1000;
        let globalCooldownEndTime = 0;
        const enemyCollisionDamage = 5;
        const enemyDamageCooldown = 1000;
        const frostNovaRadius = 10;
        const immunityDuration = 5000;
        const enemyMoveSpeed = moveSpeed * 0.85;
        const enemyAggroRadius = 60;
        const enemyCollisionRadius = 2.0;
        const vehicleCollisionRadius = 3.0;
        const interactionRadius = 8.0;

        // --- Init ---
        function init() {
            // UI Setup
            playerHpLabel = document.getElementById('player-hp-label');
            combatLogElement = document.getElementById('combat-log');
            gameOverScreen = document.getElementById('game-over');
            abilityBarElement = document.getElementById('ability-bar');
            speedometerElement = document.getElementById('speedometer');
            altimeterElement = document.getElementById('altimeter');
            nitroUiElement = document.getElementById('nitro-ui');
            nitroBarElement = document.getElementById('nitro-bar');
            interactionPromptElement = document.getElementById('interaction-prompt');
            flightControlsInfo = document.getElementById('flight-controls');
            for (let i = 1; i <= 5; i++) {
                abilityButtons.push(document.getElementById(`ability-${i}`));
            }

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky Blue
            scene.fog = new THREE.Fog(0x87CEEB, FOG_DIST * 0.5, FOG_DIST);

            camera = new THREE.PerspectiveCamera(baseCameraFOV, window.innerWidth / window.innerHeight, 0.1, 4000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Scene Objects
            setupLighting();
            setupMassiveCity(); // NEW: Procedural City
            setupPlayer();
            setupCar();
            setupPlane();
            setupEnemies();

            setupEventListeners();
            setCameraMode('onFoot');
            updateHpLabels();
            logCombatMessage("Welcome to the Massive World!");
            logCombatMessage("Find the Car or Plane to explore.");
            updateUIState();
            animate();
        }

        // --- Setup Functions ---
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Directional light follows player conceptually, but we set it high up
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 500, 200);
            directionalLight.castShadow = true;

            // Massive shadow map for massive world (though quality will drop at distance)
            const d = 300; // Shadow box size
            directionalLight.shadow.camera.left = -d;
            directionalLight.shadow.camera.right = d;
            directionalLight.shadow.camera.top = d;
            directionalLight.shadow.camera.bottom = -d;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 1000;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
        }

        function setupMassiveCity() {
            // 1. The Ground (Infinite looking plane)
            const groundGeometry = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x556B2F, // Natural Green (Throttle.html style)
                roughness: 0.9
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.position.y = -0.05;
            scene.add(ground);

            // 2. Instanced Buildings
            // We calculate how many blocks fit in the world
            const blocksPerSide = Math.floor(WORLD_SIZE / BLOCK_SIZE);
            const totalBlocks = blocksPerSide * blocksPerSide;

            // Building Geometry (Simple Box)
            const buildGeo = new THREE.BoxGeometry(1, 1, 1);
            const buildMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.1 });
            buildingsInstancedMesh = new THREE.InstancedMesh(buildGeo, buildMat, totalBlocks);
            buildingsInstancedMesh.castShadow = true;
            buildingsInstancedMesh.receiveShadow = true;

            // Tree Geometry (Merged for instancing)
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 2);
            trunkGeo.translate(0, 1, 0);
            const leavesGeo = new THREE.ConeGeometry(2.5, 6, 8);
            leavesGeo.translate(0, 5, 0);
            // Note: Merging geometries for instancing usually requires buffer geometry manipulation, 
            // but for simplicity in this single file, we will just instance the leaves and trunk separately 
            // or just make trees simple Cones for performance. Let's use simple Cones for trees.
            const treeGeo = new THREE.ConeGeometry(1.5, 6, 8);
            const treeMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            treesInstancedMesh = new THREE.InstancedMesh(treeGeo, treeMat, totalBlocks * 2); // 2 trees per block approx
            treesInstancedMesh.castShadow = true;
            treesInstancedMesh.receiveShadow = true;

            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            let treeIdx = 0;
            let buildIdx = 0;

            const halfWorld = WORLD_SIZE / 2;

            // Loop through grid
            for (let x = -halfWorld; x < halfWorld; x += BLOCK_SIZE) {
                for (let z = -halfWorld; z < halfWorld; z += BLOCK_SIZE) {

                    // Clear center area for starting zone
                    if (Math.abs(x) < 150 && Math.abs(z) < 150) continue;

                    // DENSITY CHANGE: 
                    // 30% chance of a building, 70% chance of park/nature
                    // (Previous was 80% building)
                    const isPark = Math.random() > 0.3;

                    if (!isPark) {
                        // Building
                        const width = BLOCK_SIZE - ROAD_WIDTH - (Math.random() * 10);
                        const depth = BLOCK_SIZE - ROAD_WIDTH - (Math.random() * 10);
                        const height = 20 + Math.random() * 80 + (Math.random() > 0.95 ? 150 : 0); // Occasional skyscraper

                        dummy.position.set(x + BLOCK_SIZE / 2, height / 2, z + BLOCK_SIZE / 2);
                        dummy.rotation.set(0, 0, 0);
                        dummy.scale.set(width, height, depth);
                        dummy.updateMatrix();

                        buildingsInstancedMesh.setMatrixAt(buildIdx, dummy.matrix);

                        // Random Building Color
                        const grey = 0.2 + Math.random() * 0.6;
                        color.setRGB(grey, grey, grey + (Math.random() * 0.1));
                        buildingsInstancedMesh.setColorAt(buildIdx, color);

                        buildIdx++;
                    } else {
                        // Park (Trees)
                        const numTrees = 2 + Math.floor(Math.random() * 4);
                        for (let t = 0; t < numTrees; t++) {
                            const tx = x + ROAD_WIDTH / 2 + Math.random() * (BLOCK_SIZE - ROAD_WIDTH);
                            const tz = z + ROAD_WIDTH / 2 + Math.random() * (BLOCK_SIZE - ROAD_WIDTH);
                            const th = 1 + Math.random() * 2; // scale height

                            dummy.position.set(tx, 3 * th, tz); // pivot is center, so lift up
                            dummy.scale.set(th, th, th);
                            dummy.updateMatrix();

                            if (treeIdx < treesInstancedMesh.count) {
                                treesInstancedMesh.setMatrixAt(treeIdx, dummy.matrix);
                                treeIdx++;
                            }
                        }
                    }
                }
            }

            scene.add(buildingsInstancedMesh);
            scene.add(treesInstancedMesh);
        }

        // --- Procedural Collision Logic (O(1)) ---
        function checkCityCollision(position, radius = 1.0) {
            // Don't collide in the starting safe zone
            if (Math.abs(position.x) < 100 && Math.abs(position.z) < 100) return 0;

            // Map position to grid
            // Shift coordinates to positive range for modulo math
            const halfWorld = WORLD_SIZE / 2;
            const gridX = position.x + halfWorld;
            const gridZ = position.z + halfWorld;

            // Identify where in the block we are
            const localX = gridX % BLOCK_SIZE;
            const localZ = gridZ % BLOCK_SIZE;

            const margin = ROAD_WIDTH / 2;
            const inRoadX = (localX < margin) || (localX > BLOCK_SIZE - margin);
            const inRoadZ = (localZ < margin) || (localZ > BLOCK_SIZE - margin);

            if (inRoadX || inRoadZ) {
                return 0; // We are on a road, height 0
            }

            // If not on road, we are inside a building footprint.
            // To make this deterministic without storing 10,000 heights, we use a pseudo-random hash function based on coords.
            const blockIndexX = Math.floor(gridX / BLOCK_SIZE);
            const blockIndexZ = Math.floor(gridZ / BLOCK_SIZE);
            const seed = blockIndexX * 12345 + blockIndexZ * 67890;
            const pseudoRandom = (Math.sin(seed) * 10000) - Math.floor(Math.sin(seed) * 10000);

            // COLLISION DENSITY UPDATE:
            // Must match the generation logic (> 0.3 is park)
            const isPark = pseudoRandom > 0.3;

            if (isPark) return 0; // Parks are flat

            // Reconstruct building height
            const r2 = (Math.cos(seed) * 10000) - Math.floor(Math.cos(seed) * 10000);
            const isSkyscraper = r2 > 0.95;
            const height = 20 + pseudoRandom * 80 + (isSkyscraper ? 150 : 0);

            // Return the height of the building at this spot
            return height;
        }

        function setupPlayer() {
            player = createPlayerModel();
            player.position.set(0, playerGroundY, 0);
            player.castShadow = true;
            player.userData = { hpLabel: playerHpLabel, hpOffsetY: playerModelHeight + 0.3 };
            scene.add(player);
            playerBoundingBox.setFromObject(player);
        }

        function setupCar() {
            car = new THREE.Group(); car.position.set(10, 0.5, 10);
            const bodyGeometry = new THREE.BoxGeometry(2, 1, 4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0.3 });
            carBodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial); carBodyMesh.castShadow = true; carBodyMesh.receiveShadow = true;
            car.add(carBodyMesh);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.8, 2), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            cabin.position.set(0, 0.9, -0.5); carBodyMesh.add(cabin);

            const wGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.5, 16);
            const wMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [{ x: 1.1, z: 1.3 }, { x: -1.1, z: 1.3 }, { x: 1.1, z: -1.3 }, { x: -1.1, z: -1.3 }].forEach(p => {
                const w = new THREE.Mesh(wGeo, wMat); w.position.set(p.x, -0.1, p.z); w.rotation.z = Math.PI / 2; car.add(w);
            });
            scene.add(car); carBoundingBox.setFromObject(car);
        }

        function setupPlane() {
            plane = new THREE.Group();
            const redMat = new THREE.MeshStandardMaterial({ color: 0xd9534f, flatShading: true });
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xf7f7f7, flatShading: true });

            // Fuselage
            const fuse = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 8), whiteMat);
            fuse.castShadow = true; plane.add(fuse);
            // Wings
            const wing = new THREE.Mesh(new THREE.BoxGeometry(12, 0.2, 3), redMat);
            wing.position.set(0, 0, 0.5); wing.castShadow = true; plane.add(wing);
            // Tail
            const tailV = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2.5, 2), redMat);
            tailV.position.set(0, 1, 3.5); plane.add(tailV);
            const tailH = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 1.5), redMat);
            tailH.position.set(0, 0.5, 3.5); plane.add(tailH);
            // Prop
            propeller = new THREE.Mesh(new THREE.BoxGeometry(5, 0.1, 0.3), new THREE.MeshStandardMaterial({ color: 0x333 }));
            propeller.position.set(0, 0, -4.1); plane.add(propeller);

            plane.position.set(-15, 2, 10);
            plane.rotation.y = Math.PI / 2;
            scene.add(plane);
        }

        function createPlayerModel() {
            const g = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0x0000ff });
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.8, 0.4), mat); body.position.y = 0.9; body.castShadow = true;
            g.add(body);
            return g;
        }

        function setupEnemies() {
            // Place enemies near start
            const positions = [{ x: 20, z: 20 }, { x: -20, z: 20 }, { x: 20, z: -20 }, { x: -20, z: -20 }, { x: 40, z: 0 }];
            enemyBoundingBoxes = []; enemies = [];
            positions.forEach((p, i) => {
                const e = createEnemy(new THREE.Vector3(p.x, 0, p.z), 50, i);
                scene.add(e); enemies.push(e);
                enemyBoundingBoxes.push(new THREE.Box3().setFromObject(e));
            });
        }

        function createEnemy(position, maxHP, index) {
            const g = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 1.5), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            body.position.y = 0.6; g.add(body);
            g.position.copy(position); g.castShadow = true;

            const label = document.createElement('div'); label.className = 'hp-label'; document.body.appendChild(label);
            g.userData = { id: `Wolf ${index}`, hpLabel: label, hpOffsetY: 1.5, maxHP, currentHP: maxHP, isDead: false, baseMaterials: {}, lastDamageTime: 0 };
            g.traverse(c => { if (c.isMesh) g.userData.baseMaterials[c.uuid] = c.material; });
            return g;
        }

        // --- Event Listeners ---
        function setupEventListeners() {
            window.addEventListener("resize", () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            window.addEventListener("keydown", onKeyDown);
            window.addEventListener("keyup", onKeyUp);
            renderer.domElement.addEventListener("mousedown", onMouseDown);
            window.addEventListener("mousemove", onMouseMove);
            window.addEventListener("mouseup", onMouseUp);
            abilityButtons.forEach((btn, i) => btn.addEventListener('click', () => useAbility(i + 1)));
        }

        function onKeyDown(event) {
            const k = event.key.toLowerCase();
            if (k === 'shift') keysPressed.shift = true;
            else if (event.code === 'Space') keysPressed.space = true;
            else if (k === 'e') { keysPressed.e = true; handleInteraction(); }
            else if (k in keysPressed) keysPressed[k] = true;

            if (playerState === 'onFoot' && !isPlayerDead) {
                if (['1', '2', '3', '4', '5'].includes(k)) useAbility(parseInt(k));
                if (event.code === 'Space' && isGrounded) { playerVelocityY = jumpStrength; isGrounded = false; }
            }
        }

        function onKeyUp(event) {
            const k = event.key.toLowerCase();
            if (k === 'shift') keysPressed.shift = false;
            else if (event.code === 'Space') keysPressed.space = false;
            else if (k === 'e') keysPressed.e = false;
            else if (k in keysPressed) keysPressed[k] = false;
        }

        function onMouseDown(event) {
            if (playerState === 'onFoot' && !isPlayerDead) {
                mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(enemies, true);
                if (intersects.length > 0) {
                    let g = intersects[0].object; while (g.parent !== scene) g = g.parent;
                    if (g.userData && !g.userData.isDead) setTarget(g);
                }
            }
            if (!isPlayerDead && event.button === 0) {
                isDragging = true; previousMousePosition.x = event.clientX; previousMousePosition.y = event.clientY;
                renderer.domElement.style.cursor = 'grabbing';
            }
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                if (playerState === 'onFoot') {
                    // Standard RPG Camera controls
                    rpgCameraTheta -= deltaX * rpgCameraSensitivity;
                    rpgCameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, rpgCameraPhi - deltaY * rpgCameraSensitivity));
                } else {
                    // Vehicle Free Look (Snap-back system)
                    // We add to offsets (X = Yaw, Y = Pitch)
                    vehicleLookX += deltaX * rpgCameraSensitivity;
                    vehicleLookY += deltaY * rpgCameraSensitivity;

                    // Limit vertical look to avoid flipping under the car
                    vehicleLookY = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, vehicleLookY));
                }
                previousMousePosition.x = event.clientX; previousMousePosition.y = event.clientY;
            }
        }
        function onMouseUp() { isDragging = false; renderer.domElement.style.cursor = 'crosshair'; }

        // --- Interaction System ---
        function handleInteraction() {
            if (isPlayerDead) return;
            if (playerState === 'onFoot') {
                if (player.position.distanceTo(plane.position) < interactionRadius) enterPlane();
                else if (player.position.distanceTo(car.position) < interactionRadius) enterCar();
            } else if (playerState === 'inCar') exitCar();
            else if (playerState === 'inPlane') exitPlane();
        }

        function enterCar() {
            playerState = 'inCar'; player.visible = false;
            carSpeed = 0; isDrifting = false; isBoosting = false;
            if (carBodyMesh) carBodyMesh.rotation.z = 0;
            // Reset camera look offsets
            vehicleLookX = 0; vehicleLookY = 0;
            setCameraMode('inCar'); updateUIState(); setTarget(null);
        }

        function exitCar() {
            playerState = 'onFoot';
            const offset = new THREE.Vector3(3, 0, 0).applyQuaternion(car.quaternion);
            player.position.copy(car.position).add(offset); player.position.y = playerGroundY;
            player.visible = true; isGrounded = true; playerVelocityY = 0;
            setCameraMode('onFoot'); updateUIState();
        }

        function enterPlane() {
            playerState = 'inPlane'; player.visible = false;
            planeSpeed = 0; isBoosting = false;
            // Reset camera look offsets
            vehicleLookX = 0; vehicleLookY = 0;
            setCameraMode('inPlane'); updateUIState(); setTarget(null);
        }

        function exitPlane() {
            if (plane.position.y > 10) { logCombatMessage("Too high to exit!"); return; }
            playerState = 'onFoot';
            const offset = new THREE.Vector3(3, 0, 0).applyQuaternion(plane.quaternion);
            player.position.copy(plane.position).add(offset); player.position.y = playerGroundY;
            player.visible = true; isGrounded = true;
            plane.rotation.z = 0; plane.rotation.x = 0;
            setCameraMode('onFoot'); updateUIState();
        }

        function updateUIState() {
            const isVehicle = (playerState !== 'onFoot');
            speedometerElement.style.display = isVehicle ? 'block' : 'none';
            altimeterElement.style.display = (playerState === 'inPlane') ? 'block' : 'none';
            nitroUiElement.style.display = isVehicle ? 'block' : 'none';
            flightControlsInfo.style.display = (playerState === 'inPlane') ? 'block' : 'none';
            abilityBarElement.style.display = isVehicle ? 'none' : 'flex';
            combatLogElement.style.display = isVehicle ? 'none' : 'flex';
        }

        // --- Logic Updates ---
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const currentTime = performance.now();

            if (playerState === 'onFoot') updatePlayerPhysics(deltaTime);
            else if (playerState === 'inCar') updateCarPhysics(deltaTime);
            else if (playerState === 'inPlane') updatePlanePhysics(deltaTime);

            updateEnemyAI(deltaTime, currentTime);
            updateCamera(deltaTime);

            // UI
            if (playerState === 'inPlane') {
                speedometerElement.innerText = `SPD: ${Math.round(planeSpeed)}`;
                altimeterElement.innerText = `ALT: ${Math.round(plane.position.y)}`;
            } else if (playerState === 'inCar') {
                speedometerElement.innerText = `${Math.round(carSpeed)} MPH`;
            }

            if (playerState !== 'onFoot') {
                const p = (nitroAmount / maxNitroAmount) * 100;
                nitroBarElement.style.width = `${p}%`;
            }

            updateInteractionPrompt();
            updateHpLabels();
            renderer.render(scene, camera);
        }

        function updatePlayerPhysics(dt) {
            if (isPlayerDead) return;
            const moveDir = new THREE.Vector3(0, 0, 0);
            if (keysPressed.w) moveDir.z = -1; if (keysPressed.s) moveDir.z = 1;
            if (keysPressed.a) moveDir.x = -1; if (keysPressed.d) moveDir.x = 1;

            if (moveDir.lengthSq() > 0) {
                moveDir.normalize();
                const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); camDir.y = 0; camDir.normalize();
                const camLeft = new THREE.Vector3().crossVectors(camera.up, camDir).normalize();
                const finalMove = new THREE.Vector3().addScaledVector(camDir, -moveDir.z).addScaledVector(camLeft, -moveDir.x).normalize();

                let moveAmt = moveSpeed * dt;
                const nextPos = player.position.clone().addScaledVector(finalMove, moveAmt);

                // City Collision Check
                const buildingHeight = checkCityCollision(nextPos);
                if (buildingHeight === 0) {
                    player.position.addScaledVector(finalMove, moveAmt);
                    const qt = new THREE.Quaternion().setFromRotationMatrix(new THREE.Matrix4().lookAt(player.position, player.position.clone().add(finalMove), player.up));
                    player.quaternion.slerp(qt, 0.15);
                }
            }
            playerVelocityY -= gravity * dt; player.position.y += playerVelocityY * dt;
            if (player.position.y <= playerGroundY) { player.position.y = playerGroundY; playerVelocityY = 0; isGrounded = true; } else isGrounded = false;
        }

        function updateCarPhysics(dt) {
            if (!isBoosting && nitroAmount < maxNitroAmount) nitroAmount = Math.min(maxNitroAmount, nitroAmount + nitroRechargeRate * dt);
            if (keysPressed.shift && nitroAmount > 0) { isBoosting = true; nitroAmount = Math.max(0, nitroAmount - nitroConsumptionRate * dt); }
            else isBoosting = false;

            isDrifting = keysPressed.space && carSpeed > 30 && !isBoosting;
            let acc = carBaseAcceleration; let maxS = carBaseMaxSpeed; let turnS = carBaseTurnSpeed;
            if (isBoosting) { acc *= nitroAccelerationMultiplier; maxS *= nitroMaxSpeedMultiplier; turnS *= nitroTurnReduction; }

            if (keysPressed.w) carSpeed += acc * dt;
            else if (keysPressed.s) carSpeed -= (carSpeed > 1 ? carBrakeDeceleration : carBaseAcceleration) * dt;
            else carSpeed -= Math.sign(carSpeed) * carDeceleration * dt;

            if (Math.abs(carSpeed) < 1 && !keysPressed.w && !keysPressed.s) carSpeed = 0;
            carSpeed = Math.max(carMaxReverseSpeed, Math.min(maxS, carSpeed));

            if (Math.abs(carSpeed) > 1) {
                let turnDir = (keysPressed.a ? 1 : 0) + (keysPressed.d ? -1 : 0);
                car.rotation.y += turnS * turnDir * dt * (isDrifting ? driftTurnMultiplier : 1);
                const targetTilt = isDrifting ? (keysPressed.a ? driftTiltAngle : -driftTiltAngle) : 0;
                currentCarTilt += (targetTilt - currentCarTilt) * Math.min(1, tiltSpeed * dt);
                carBodyMesh.rotation.z = currentCarTilt;
            }

            const fwd = new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion);
            const moveVec = fwd.multiplyScalar(carSpeed * dt);
            const nextPos = car.position.clone().add(moveVec);

            // City Collision
            if (checkCityCollision(nextPos) === 0) {
                car.position.add(moveVec);
            } else {
                carSpeed = -carSpeed * 0.5; // Bounce
            }
        }

        function updatePlanePhysics(dt) {
            let targetSpeed = planeBaseSpeed;
            if (keysPressed.shift && nitroAmount > 0) { targetSpeed = planeMaxSpeed; isBoosting = true; nitroAmount = Math.max(0, nitroAmount - nitroConsumptionRate * dt); }
            else { isBoosting = false; if (nitroAmount < maxNitroAmount) nitroAmount += nitroRechargeRate * dt; }
            if (keysPressed.space) targetSpeed = planeMinSpeed;

            planeSpeed += (targetSpeed - planeSpeed) * 2.0 * dt;
            const pitchSpeed = 1.5 * dt; const rollSpeed = 2.0 * dt;

            if (keysPressed.w) plane.rotateX(pitchSpeed);
            if (keysPressed.s) plane.rotateX(-pitchSpeed);
            if (keysPressed.a) { plane.rotateZ(rollSpeed); plane.rotateY(0.5 * dt); }
            if (keysPressed.d) { plane.rotateZ(-rollSpeed); plane.rotateY(-0.5 * dt); }

            plane.translateZ(-planeSpeed * dt);
            if (propeller) propeller.rotation.z += 10 + (planeSpeed * 0.1);

            // Floor Collision
            if (plane.position.y < 2) { plane.position.y = 2; plane.rotation.x *= 0.9; plane.rotation.z *= 0.9; }

            // Building Collision
            const bHeight = checkCityCollision(plane.position);
            if (bHeight > 0 && plane.position.y < bHeight) {
                // Crash!
                plane.position.y = bHeight + 1; // Push up
                planeSpeed = 0;
                logCombatMessage("CRASHED into building!");
                playerCurrentHP -= 10;
                if (playerCurrentHP <= 0) handlePlayerDeath();
                updateHpLabels();
            }
        }

        function updateEnemyAI(dt, time) {
            enemies.forEach((e, i) => { if (!e.userData.isDead) enemyBoundingBoxes[i].setFromObject(e); });
            const targetObj = (playerState === 'inCar') ? car : (playerState === 'inPlane' ? plane : player);
            if (playerState === 'inPlane' && plane.position.y > 10) return;

            const targetPos = targetObj.position;
            const colRad = (playerState === 'onFoot') ? enemyCollisionRadius : vehicleCollisionRadius;

            enemies.forEach((enemy, i) => {
                if (enemy.userData.isDead || isPlayerDead) return;
                const distSq = targetPos.distanceToSquared(enemy.position);
                if (distSq < enemyAggroRadius ** 2) {
                    if (distSq > colRad ** 2 * 1.1) {
                        const dir = new THREE.Vector3().subVectors(targetPos, enemy.position);
                        dir.y = 0; dir.normalize();
                        const moveAmt = enemyMoveSpeed * dt;
                        const potentialPos = enemy.position.clone().addScaledVector(dir, moveAmt);

                        // Simple city collision for enemies
                        if (checkCityCollision(potentialPos) === 0) {
                            enemy.position.addScaledVector(dir, moveAmt);
                            enemy.quaternion.slerp(new THREE.Quaternion().setFromRotationMatrix(new THREE.Matrix4().lookAt(enemy.position, enemy.position.clone().add(dir), enemy.up)), 0.1);
                        }
                    }
                    if (distSq < colRad ** 2 && time > enemy.userData.lastDamageTime + enemyDamageCooldown) {
                        applyDamage(player, enemyCollisionDamage, enemy.userData.id);
                        enemy.userData.lastDamageTime = time;
                        flashObject(playerState === 'onFoot' ? player : (playerState === 'inCar' ? car : plane), 0xff0000);
                        updateHpLabels();
                    }
                }
            });
        }

        function updateCamera(dt) {
            if (playerState === 'onFoot') {
                cameraTarget.copy(player.position).y += playerModelHeight * 0.6;
                const x = cameraTarget.x + rpgCameraRadius * Math.sin(rpgCameraPhi) * Math.sin(rpgCameraTheta);
                const y = cameraTarget.y + rpgCameraRadius * Math.cos(rpgCameraPhi);
                const z = cameraTarget.z + rpgCameraRadius * Math.sin(rpgCameraPhi) * Math.cos(rpgCameraTheta);
                camera.position.set(x, y, z);
                camera.lookAt(cameraTarget);
                currentCameraFOV = baseCameraFOV;
            } else if (playerState === 'inCar') {
                // 1. Snap Back Logic (Decay offsets when not dragging)
                if (!isDragging) {
                    const returnSpeed = 5.0; // Snap speed
                    vehicleLookX = THREE.MathUtils.lerp(vehicleLookX, 0, dt * returnSpeed);
                    vehicleLookY = THREE.MathUtils.lerp(vehicleLookY, 0, dt * returnSpeed);
                }

                // 2. Calculate Camera Position based on offsets
                // Start with the base relative offset (Standard chase view)
                const offset = carCameraOffset.clone(); // e.g., (0, 8, -15)

                // Apply the Mouse Look rotations (in Local Space)
                // Pitch (Around X axis)
                offset.applyAxisAngle(new THREE.Vector3(1, 0, 0), -vehicleLookY);
                // Yaw (Around Y axis)
                offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), -vehicleLookX);

                // Transform this Local Offset into World Space using the Car's orientation
                offset.applyQuaternion(car.quaternion);

                // Add to Car Position to get final Camera Position
                const targetPos = car.position.clone().add(offset);

                // 3. Apply Smoothing (Faster when dragging for responsiveness)
                camera.position.lerp(targetPos, isDragging ? 0.4 : 0.1);

                // 4. FOV Logic
                let targetFOV = isBoosting ? boostCameraFOV : baseCameraFOV;
                currentCameraFOV += (targetFOV - currentCameraFOV) * Math.min(1, fovChangeSpeed * dt);
                camera.fov = currentCameraFOV; camera.updateProjectionMatrix();

                // 5. Look At Target
                // Look at slightly above the car center so the car stays in view while rotating
                const lookTarget = car.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                camera.lookAt(lookTarget);

            } else if (playerState === 'inPlane') {
                // Same logic for Plane
                if (!isDragging) {
                    const returnSpeed = 5.0;
                    vehicleLookX = THREE.MathUtils.lerp(vehicleLookX, 0, dt * returnSpeed);
                    vehicleLookY = THREE.MathUtils.lerp(vehicleLookY, 0, dt * returnSpeed);
                }

                // Base plane offset
                const baseOffset = new THREE.Vector3(0, 8, 25); // Behind and above

                // Apply look rotations
                baseOffset.applyAxisAngle(new THREE.Vector3(1, 0, 0), -vehicleLookY);
                baseOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), -vehicleLookX);

                // Apply Plane Rotation (World space)
                baseOffset.applyQuaternion(plane.quaternion); // Use quaternion instead of matrixWorld for smoother vector math

                const idealPos = plane.position.clone().add(baseOffset);
                camera.position.lerp(idealPos, isDragging ? 0.4 : 0.05);

                // Look at plane
                camera.lookAt(plane.position);

                camera.fov = isBoosting ? 95 : 80;
                camera.updateProjectionMatrix();
            }
        }

        function setCameraMode(mode) {
            if (mode === 'inCar') camera.position.copy(car.position).add(new THREE.Vector3(0, 10, -10));
            else if (mode === 'inPlane') camera.position.copy(plane.position).add(new THREE.Vector3(0, 10, 20));
            else { camera.fov = baseCameraFOV; camera.updateProjectionMatrix(); }
        }

        function updateInteractionPrompt() {
            interactionPromptElement.style.display = 'none';
            if (isPlayerDead) return;
            if (playerState === 'onFoot') {
                if (player.position.distanceTo(car.position) < interactionRadius) { interactionPromptElement.style.display = 'block'; interactionPromptElement.innerText = 'Press [E] to Drive'; }
                else if (player.position.distanceTo(plane.position) < interactionRadius) { interactionPromptElement.style.display = 'block'; interactionPromptElement.innerText = 'Press [E] to Fly'; }
            } else if (playerState === 'inCar') { interactionPromptElement.style.display = 'block'; interactionPromptElement.innerText = 'Press [E] to Exit'; }
            else if (playerState === 'inPlane' && plane.position.y < 10) { interactionPromptElement.style.display = 'block'; interactionPromptElement.innerText = 'Press [E] to Exit'; }
        }

        function setTarget(t) {
            if (currentTarget && currentTarget !== t && !currentTarget.userData.isDead) currentTarget.traverse(c => { if (c.isMesh && currentTarget.userData.baseMaterials[c.uuid]) c.material = currentTarget.userData.baseMaterials[c.uuid]; });
            currentTarget = t;
            if (currentTarget) { currentTarget.traverse(c => { if (c.isMesh && c.material.emissive) c.material.emissive.setHex(targetHighlightColor); }); logCombatMessage(`Targeted ${currentTarget.userData.id}`); }
        }

        function useAbility(id) {
            if (playerState !== 'onFoot' || isPlayerDead) return;
            if (performance.now() < globalCooldownEndTime) { logCombatMessage("Cooldown..."); return; }
            const t = currentTarget;
            if ([1, 3, 4].includes(id) && (!t || t.userData.isDead)) { logCombatMessage("No Target"); return; }
            if ([1, 3].includes(id) && player.position.distanceTo(t.position) > attackRange) { logCombatMessage("Out of Range"); return; }
            let msg = "";
            if (id === 1) { applyDamage(t, 10); flashObject(t, 0xffff00); msg = "Melee Hit (10)"; }
            else if (id === 2) { isPlayerImmune = true; playerImmunityEndTime = performance.now() + immunityDuration; showImmunityVisual(true); msg = "Shield Up"; }
            else if (id === 3) { applyDamage(t, 15); flashObject(t, 0xff8c00); msg = "Fireball (15)"; }
            else if (id === 4) { createFrostAoe(t.position); enemies.forEach(e => { if (!e.userData.isDead && e.position.distanceTo(t.position) < frostNovaRadius) { applyDamage(e, 30); flashObject(e, 0x00ffff); } }); msg = "Frost Nova"; }
            else if (id === 5) { playerCurrentHP = Math.min(playerMaxHP, playerCurrentHP + 20); flashObject(player, 0x00ff00); msg = "Healed"; }
            logCombatMessage(msg); updateHpLabels(); globalCooldownEndTime = performance.now() + globalCooldownDuration;
            abilityButtons.forEach(b => b.classList.add('on-cooldown')); setTimeout(() => abilityButtons.forEach(b => b.classList.remove('on-cooldown')), globalCooldownDuration);
        }

        function applyDamage(t, amt, src = "Hit") {
            if (!t || isPlayerDead) return;
            if (t === player) { if (isPlayerImmune) return; playerCurrentHP = Math.max(0, playerCurrentHP - amt); if (playerCurrentHP <= 0) handlePlayerDeath(); }
            else { t.userData.currentHP = Math.max(0, t.userData.currentHP - amt); if (t.userData.currentHP <= 0) handleEnemyDeath(t); }
        }

        function handleEnemyDeath(e) { e.userData.isDead = true; e.traverse(c => { if (c.isMesh) c.material = new THREE.MeshStandardMaterial({ color: 0x555555 }); }); if (currentTarget === e) setTarget(null); logCombatMessage("Enemy Defeated"); }
        function handlePlayerDeath() { isPlayerDead = true; gameOverScreen.style.display = 'flex'; if (playerState !== 'onFoot') { if (playerState === 'inCar') exitCar(); else exitPlane(); } }

        function flashObject(obj, color) {
            if (!obj) return;
            const restore = (o, mat) => { setTimeout(() => { if (o && o.material) o.material = mat; }, 150); };
            obj.traverse(c => { if (c.isMesh && c.material) { const clone = c.material.clone(); clone.emissive.setHex(color); const orig = c.material; c.material = clone; restore(c, orig); } });
        }

        function createFrostAoe(pos) { const mesh = new THREE.Mesh(new THREE.RingGeometry(0.1, frostNovaRadius, 32), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, side: THREE.DoubleSide })); mesh.rotation.x = -Math.PI / 2; mesh.position.copy(pos).setY(0.1); scene.add(mesh); setTimeout(() => scene.remove(mesh), 500); }
        function showImmunityVisual(show) { if (show) { if (!immunityVisual) { immunityVisual = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })); player.add(immunityVisual); } immunityVisual.visible = true; } else if (immunityVisual) immunityVisual.visible = false; }

        function updateHpLabels() {
            if (player && player.userData.hpLabel) player.userData.hpLabel.textContent = `HP: ${playerCurrentHP}/${playerMaxHP}`;
            enemies.forEach(e => {
                if (e.userData.hpLabel) {
                    e.userData.hpLabel.textContent = e.userData.isDead ? "Dead" : `${e.userData.id}: ${e.userData.currentHP}`;
                    const pos = e.position.clone().setY(e.position.y + e.userData.hpOffsetY).project(camera);
                    if (pos.z < 1 && Math.abs(pos.x) < 1 && Math.abs(pos.y) < 1) {
                        e.userData.hpLabel.style.left = `${(pos.x * .5 + .5) * window.innerWidth}px`; e.userData.hpLabel.style.top = `${(-pos.y * .5 + .5) * window.innerHeight}px`; e.userData.hpLabel.style.display = 'block';
                    } else e.userData.hpLabel.style.display = 'none';
                }
            });
            if (player.userData.hpLabel) {
                const pos = player.position.clone().setY(player.position.y + 2.2).project(camera);
                if (pos.z < 1 && player.visible) { player.userData.hpLabel.style.left = `${(pos.x * .5 + .5) * window.innerWidth}px`; player.userData.hpLabel.style.top = `${(-pos.y * .5 + .5) * window.innerHeight}px`; player.userData.hpLabel.style.display = 'block'; } else player.userData.hpLabel.style.display = 'none';
            }
        }
        function logCombatMessage(msg) { const p = document.createElement('p'); p.innerText = msg; combatLogElement.prepend(p); if (combatLogElement.children.length > 8) combatLogElement.lastChild.remove(); }

        init();
    </script>
</body>

</html>