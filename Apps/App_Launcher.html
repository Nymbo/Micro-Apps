<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HTML App Launcher — Multi‑File Viewer</title>
  <!-- Tailwind CSS via CDN for a modern dark UI -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Tailwind config: lock us in dark mode for consistent look
    tailwind.config = { theme: { extend: {} }, darkMode: "class" };
  </script>
  <style>
    /* --- Minimal extras beyond Tailwind --- */
    /* Custom thin scrollbar to match the dark theme */
    ::-webkit-scrollbar { width: 10px; height: 10px; }
    ::-webkit-scrollbar-track { background: #111827; }
    ::-webkit-scrollbar-thumb { background: #374151; border-radius: 6px; }
    ::-webkit-scrollbar-thumb:hover { background: #4b5563; }

    /* Sidebar resizer handle */
    .resizer { width: 6px; cursor: col-resize; background: #1f2937; }
    .resizer:hover { background: #334155; }

    /* Simple fade-in for iframe content changes */
    .fade-enter { opacity: 0; }
    .fade-enter-active { transition: opacity .18s ease-out; opacity: 1; }

    /* Prevent text selection while dragging the resizer */
  .no-select { -webkit-user-select: none; user-select: none; }
  </style>
</head>
<body class="dark bg-gray-900 text-gray-200 min-h-screen flex flex-col">
  <!--
    File: public/html-app-launcher.html

    WHAT THIS DOES (in plain English):
    - Lets you load multiple standalone HTML files at once (drag & drop or file chooser).
    - Shows them in a sidebar list so you can instantly switch which one is displayed.
    - Renders the chosen file inside a sandboxed <iframe> that allows scripts to run.
    - Supports quick actions (open in new tab, refresh), simple search, and session export/import.
    - Keyboard shortcuts: see the cheat sheet at the bottom.
  -->

  <!-- ===== Top Bar (title + primary actions) ===== -->
  <header class="w-full border-b border-gray-800 px-3 sm:px-4 py-2 flex items-center gap-2">
    <h1 class="text-lg sm:text-xl font-semibold tracking-tight">
      HTML App Launcher
    </h1>

    <!-- Spacer -->
    <div class="flex-1"></div>

    <!-- Upload button (hidden real input, pretty button triggers it) -->
  <input id="file-input" type="file" accept=".html,.htm,text/html" multiple class="hidden" aria-label="Add HTML files" title="Add HTML files" />
    <button id="btn-add" class="px-3 py-1.5 rounded-lg bg-blue-600 hover:bg-blue-500 active:bg-blue-700 text-white text-sm font-medium">
      + Add HTML
    </button>

    <!-- Import/Export session (JSON with names + file contents) -->
  <input id="session-input" type="file" accept="application/json" class="hidden" aria-label="Import session file (JSON)" title="Import session file (JSON)" />
    <button id="btn-import" class="px-3 py-1.5 rounded-lg bg-emerald-600 hover:bg-emerald-500 active:bg-emerald-700 text-white text-sm font-medium">
      Import Session
    </button>
    <button id="btn-export" class="px-3 py-1.5 rounded-lg bg-emerald-700/70 hover:bg-emerald-600 active:bg-emerald-800 text-white text-sm font-medium">
      Export Session
    </button>

    <!-- Clear all -->
    <button id="btn-clear" class="ml-1 px-3 py-1.5 rounded-lg bg-red-600/90 hover:bg-red-500 active:bg-red-700 text-white text-sm font-medium">
      Clear
    </button>
  </header>

  <!-- ===== Main Split Layout: Sidebar (list) | Resizer | Viewer (iframe) ===== -->
  <main id="main" class="flex-1 min-h-0 flex">
    <!-- Sidebar with drag/drop + search + file list -->
    <aside id="sidebar" class="w-[320px] min-w-[220px] max-w-[560px] border-r border-gray-800 flex flex-col">
      <!-- Drag & drop overlay area -->
      <div id="dropzone" class="m-3 rounded-xl border border-dashed border-gray-700 p-3 text-gray-300 bg-gray-800/40">
        <p class="text-sm"><strong>Drop HTML files here</strong> or click <span class="underline">+ Add HTML</span>.</p>
        <p class="text-xs text-gray-400 mt-1">Accepts .html / .htm. Files are opened locally; nothing is uploaded.</p>
      </div>

      <!-- Search input to filter list -->
      <div class="px-3 mb-2">
        <label class="sr-only" for="search">Search</label>
        <input id="search" type="text" placeholder="Search files…" class="w-full bg-gray-800 border border-gray-700 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-600" />
      </div>

      <!-- List of loaded files -->
      <ul id="file-list" class="flex-1 overflow-auto px-2 pb-2 space-y-1" aria-label="Loaded HTML files"></ul>
    </aside>

    <!-- Vertical resizer between sidebar and viewer -->
    <div id="resizer" class="resizer" title="Drag to resize sidebar" role="separator" aria-orientation="vertical" aria-label="Resize sidebar"></div>

    <!-- Viewer pane: toolbar + iframe -->
    <section class="flex-1 min-w-0 flex flex-col">
      <!-- Viewer toolbar -->
      <div class="px-3 sm:px-4 py-2 border-b border-gray-800 flex items-center gap-2">
        <div id="current-file" class="truncate text-sm text-gray-300">No file selected</div>
        <div class="flex-1"></div>
        <button id="btn-open-new" class="px-3 py-1.5 rounded-lg bg-gray-700 hover:bg-gray-600 text-sm">Open in New Tab</button>
        <button id="btn-refresh" class="px-3 py-1.5 rounded-lg bg-gray-700 hover:bg-gray-600 text-sm">Refresh</button>
        <button id="btn-remove" class="px-3 py-1.5 rounded-lg bg-gray-700 hover:bg-gray-600 text-sm">Remove</button>
      </div>

      <!-- The actual embedded viewer -->
      <div class="flex-1 min-h-0">
        <!--
          Important: we sandbox the iframe but allow scripts + same-origin so apps can run as expected
          without escaping into the parent page. Popups are allowed so new windows work.
        -->
        <iframe id="viewer" class="w-full h-full bg-gray-900 fade-enter" sandbox="allow-scripts allow-same-origin allow-forms allow-modals allow-popups allow-downloads" title="HTML preview"></iframe>
      </div>
    </section>
  </main>

  <!-- ===== Keyboard Shortcuts / Help ===== -->
  <footer class="border-t border-gray-800 px-3 sm:px-4 py-2 text-xs text-gray-400">
    <div class="flex flex-col sm:flex-row gap-2 sm:items-center sm:justify-between">
      <div>Tip: drag the divider to resize the sidebar.</div>
      <ul class="flex flex-wrap gap-x-4 gap-y-1">
        <li><span class="text-gray-300">Alt+→</span> next</li>
        <li><span class="text-gray-300">Alt+←</span> previous</li>
        <li><span class="text-gray-300">Ctrl+O</span> add files</li>
        <li><span class="text-gray-300">Ctrl+Shift+R</span> refresh</li>
        <li><span class="text-gray-300">Enter</span> open in new tab</li>
        <li><span class="text-gray-300">Del</span> remove</li>
      </ul>
    </div>
  </footer>

  <script>
    // =========================
    // State & utilities
    // =========================

    /** @type {Array<{ id:string, name:string, alias:string, size:number, mtime:number, text:string, url:string }>} */
    const files = []; // holds the loaded HTML files in memory
    let selectedIndex = -1; // which item in `files` is currently shown

    // Quick ID generator so each file has a stable key
    const uid = () => Math.random().toString(36).slice(2, 10) + Date.now().toString(36).slice(-4);

    // DOM refs
    const el = {
      fileInput: document.getElementById('file-input'),
      sessionInput: document.getElementById('session-input'),
      addBtn: document.getElementById('btn-add'),
      importBtn: document.getElementById('btn-import'),
      exportBtn: document.getElementById('btn-export'),
      clearBtn: document.getElementById('btn-clear'),
      list: document.getElementById('file-list'),
      search: document.getElementById('search'),
      viewer: document.getElementById('viewer'),
      current: document.getElementById('current-file'),
      openNew: document.getElementById('btn-open-new'),
      refresh: document.getElementById('btn-refresh'),
      remove: document.getElementById('btn-remove'),
      dropzone: document.getElementById('dropzone'),
      sidebar: document.getElementById('sidebar'),
      resizer: document.getElementById('resizer'),
      main: document.getElementById('main'),
    };

    // Helper to revoke an object URL safely
    function revokeUrl(u) { try { if (u) URL.revokeObjectURL(u); } catch (_) {} }

    // Build a blob URL from stored text (so we can truly refresh/bust caches)
    function makeUrlFromText(text) {
      const blob = new Blob([text], { type: 'text/html' });
      return URL.createObjectURL(blob);
    }

    // Render the sidebar list, applying search filter
    function renderList() {
      const q = el.search.value.trim().toLowerCase();
      el.list.innerHTML = '';

      files.forEach((f, i) => {
        const label = (f.alias || f.name).toLowerCase();
        const visible = !q || label.includes(q);
        if (!visible) return;

        const li = document.createElement('li');
        li.className = 'group';

        const isSelected = i === selectedIndex;
        const row = document.createElement('button');
        row.type = 'button';
        row.className = [
          'w-full text-left px-3 py-2 rounded-lg border',
          isSelected ? 'bg-blue-600/20 border-blue-600/40' : 'bg-gray-800/60 border-gray-700 hover:bg-gray-700/60',
          'flex items-center gap-2',
        ].join(' ');
        row.title = `${f.name} (double‑click to rename)`;
        row.addEventListener('click', () => selectIndex(i));
        row.addEventListener('dblclick', () => promptRename(i));

        // Name/alias + size meta
        const nameDiv = document.createElement('div');
        nameDiv.className = 'flex-1 min-w-0';
        const mainName = document.createElement('div');
        mainName.className = 'truncate text-sm';
        mainName.textContent = f.alias || f.name;
        const meta = document.createElement('div');
        meta.className = 'text-[11px] text-gray-400 truncate';
        meta.textContent = `${(f.size/1024).toFixed(1)} KB • ${new Date(f.mtime).toLocaleString()}`;
        nameDiv.appendChild(mainName);
        nameDiv.appendChild(meta);

        // Quick actions (small icons as text to keep it dependency‑free)
        const openBtn = document.createElement('button');
        openBtn.className = 'text-xs px-2 py-1 rounded bg-gray-700 hover:bg-gray-600';
        openBtn.textContent = 'Open';
        openBtn.title = 'Open in new tab';
        openBtn.addEventListener('click', (e) => { e.stopPropagation(); openInNewTab(i); });

        const delBtn = document.createElement('button');
        delBtn.className = 'text-xs px-2 py-1 rounded bg-gray-700 hover:bg-red-600/80';
        delBtn.textContent = '✕';
        delBtn.title = 'Remove from list';
        delBtn.addEventListener('click', (e) => { e.stopPropagation(); removeIndex(i); });

        row.appendChild(nameDiv);
        row.appendChild(openBtn);
        row.appendChild(delBtn);
        li.appendChild(row);
        el.list.appendChild(li);
      });
    }

    // Select a given index and show it in the iframe
    function selectIndex(i) {
      if (i < 0 || i >= files.length) return;
      selectedIndex = i;
      // Fade hint
      el.viewer.classList.remove('fade-enter-active');
      el.viewer.classList.add('fade-enter');

      const f = files[i];
      el.current.textContent = f ? (f.alias || f.name) : 'No file selected';

      // Write HTML directly to iframe's contentDocument
      const iframe = el.viewer;
      const doc = iframe.contentDocument || iframe.contentWindow.document;
      doc.open();
      doc.write(f.text);
      doc.close();

      requestAnimationFrame(() => {
        el.viewer.classList.add('fade-enter-active');
      });

      renderList();
    }

    // Prompt to rename the alias shown in the list (does not change original filename)
    function promptRename(i) {
      const current = files[i];
      if (!current) return;
      const alias = prompt('Rename (alias):', current.alias || current.name);
      if (alias == null) return; // cancelled
      current.alias = alias.trim() || current.name;
      renderList();
      if (i === selectedIndex) el.current.textContent = current.alias || current.name;
    }

    // Remove an entry from the list and clean its object URL
    function removeIndex(i) {
      const f = files[i];
      if (!f) return;
      revokeUrl(f.url);
      files.splice(i, 1);
      if (selectedIndex >= files.length) selectedIndex = files.length - 1;
      renderList();
      if (selectedIndex >= 0) selectIndex(selectedIndex); else showPlaceholder();
    }

    // Completely clear list
    function clearAll() {
      files.forEach(f => revokeUrl(f.url));
      files.length = 0;
      selectedIndex = -1;
      renderList();
      showPlaceholder();
    }

    // Open selected in a new tab
    function openInNewTab(i = selectedIndex) {
      const f = files[i];
      if (!f) return;
      const url = f.url || (f.url = makeUrlFromText(f.text));
      window.open(url, '_blank');
    }

    // Refresh = rebuild object URL so scripts/styles fully reload
    function refreshSelected() {
  const f = files[selectedIndex];
  if (!f) return;
  // Just re-write the content
  selectIndex(selectedIndex);
    }

    // Simple placeholder page when nothing is selected
    function showPlaceholder() {
      const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><title>Preview</title></head>
      <body style="margin:0;min-height:100vh;display:grid;place-items:center;background:#0b1020;color:#8a93a6;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial">
        <div style="opacity:.85;text-align:center">
          <div style="font-size:14px">Load HTML files to view them here.</div>
        </div>
      </body></html>`;
      el.viewer.srcdoc = html;
      el.current.textContent = 'No file selected';
    }

    // Core: read dropped/selected files, store their text, create URLs, add to list
    async function addFiles(fileList) {
      const htmlFiles = Array.from(fileList || []).filter(f => /\.(html?|txt)$/i.test(f.name));
      if (!htmlFiles.length) return;

      // Read all texts in parallel
      const texts = await Promise.all(htmlFiles.map(f => f.text().catch(() => '')));
      htmlFiles.forEach((f, idx) => {
        const text = texts[idx] ?? '';
        const entry = {
          id: uid(),
          name: f.name,
          alias: f.name,
          size: f.size,
          mtime: f.lastModified || Date.now(),
          text,
          url: makeUrlFromText(text),
        };
        files.push(entry);
      });

      // Auto-select the last added file for convenience
      selectedIndex = files.length - 1;
      renderList();
      selectIndex(selectedIndex);
    }

    // Session export: download a JSON with names + text contents
    function exportSession() {
      if (!files.length) return alert('No files to export.');
      const data = { version: 1, exportedAt: Date.now(), files: files.map(f => ({ name: f.name, alias: f.alias, text: f.text })) };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'html-launcher-session.json';
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    // Session import: read JSON, rebuild entries
    async function importSessionFile(file) {
      const text = await file.text();
      let data = null;
      try { data = JSON.parse(text); } catch (_) {}
      if (!data || !Array.isArray(data.files)) return alert('Invalid session file.');

      data.files.forEach(item => {
        const entry = {
          id: uid(),
          name: item.name || 'imported.html',
          alias: item.alias || item.name || 'imported.html',
          size: (item.text || '').length,
          mtime: Date.now(),
          text: String(item.text || ''),
          url: makeUrlFromText(String(item.text || '')),
        };
        files.push(entry);
      });

      selectedIndex = files.length - 1;
      renderList();
      selectIndex(selectedIndex);
    }

    // =========================
    // Event wiring
    // =========================

    // Buttons for file add/import/export/clear
    el.addBtn.addEventListener('click', () => el.fileInput.click());
    el.fileInput.addEventListener('change', (e) => { addFiles(e.target.files); el.fileInput.value = ''; });

    el.importBtn.addEventListener('click', () => el.sessionInput.click());
    el.sessionInput.addEventListener('change', (e) => {
      const f = e.target.files?.[0];
      if (f) importSessionFile(f);
      el.sessionInput.value = '';
    });

    el.exportBtn.addEventListener('click', exportSession);
    el.clearBtn.addEventListener('click', () => { if (confirm('Remove all loaded files?')) clearAll(); });

    // Drag & drop
    ;['dragenter','dragover'].forEach(type => el.dropzone.addEventListener(type, (e) => {
      e.preventDefault(); e.stopPropagation();
      el.dropzone.classList.add('ring-2','ring-blue-600');
    }));
    ;['dragleave','drop'].forEach(type => el.dropzone.addEventListener(type, (e) => {
      e.preventDefault(); e.stopPropagation();
      el.dropzone.classList.remove('ring-2','ring-blue-600');
    }));
    el.dropzone.addEventListener('drop', (e) => {
      const dt = e.dataTransfer; if (!dt) return;
      addFiles(dt.files);
    });

    // Search filter
    el.search.addEventListener('input', renderList);

    // Viewer toolbar
    el.openNew.addEventListener('click', () => openInNewTab());
    el.refresh.addEventListener('click', refreshSelected);
    el.remove.addEventListener('click', () => removeIndex(selectedIndex));

    // Keyboard shortcuts (kept simple to avoid fighting the browser)
    window.addEventListener('keydown', (e) => {
      // Don't hijack keys if user is typing in inputs
      const tag = (e.target && e.target.tagName || '').toLowerCase();
      const isTyping = tag === 'input' || tag === 'textarea';

      // Ctrl+O => add files
      if (e.ctrlKey && !e.shiftKey && !e.altKey && e.key.toLowerCase() === 'o') {
        e.preventDefault(); el.fileInput.click(); return;
      }
      // Ctrl+Shift+R => refresh
      if (e.ctrlKey && e.shiftKey && !e.altKey && (e.key.toLowerCase() === 'r')) {
        e.preventDefault(); refreshSelected(); return;
      }
      // Alt+ArrowRight => next
      if (!isTyping && e.altKey && e.key === 'ArrowRight') {
        e.preventDefault(); if (files.length) selectIndex((selectedIndex + 1) % files.length); return;
      }
      // Alt+ArrowLeft => prev
      if (!isTyping && e.altKey && e.key === 'ArrowLeft') {
        e.preventDefault(); if (files.length) selectIndex((selectedIndex - 1 + files.length) % files.length); return;
      }
      // Enter => open in new tab (if focus not in an input)
      if (!isTyping && e.key === 'Enter') {
        e.preventDefault(); openInNewTab(); return;
      }
      // Delete => remove
      if (!isTyping && (e.key === 'Delete' || e.key === 'Backspace')) {
        if (selectedIndex >= 0) { e.preventDefault(); removeIndex(selectedIndex); }
      }
    });

    // Sidebar resizer logic
    (function enableSidebarResizer(){
      const bar = el.resizer;
      const sidebar = el.sidebar;
      const main = el.main;
      let dragging = false;

      const onMove = (clientX) => {
        const rect = main.getBoundingClientRect();
        const min = 220; const max = Math.min(560, rect.width - 320);
        const x = Math.min(Math.max(clientX - rect.left, min), Math.max(min, max));
        sidebar.style.width = x + 'px';
      };

      bar.addEventListener('pointerdown', (e) => {
        dragging = true; bar.setPointerCapture?.(e.pointerId);
        document.body.classList.add('no-select');
      });
      window.addEventListener('pointermove', (e) => { if (dragging) onMove(e.clientX); });
      window.addEventListener('pointerup', (e) => {
        if (dragging) { dragging = false; bar.releasePointerCapture?.(e.pointerId); document.body.classList.remove('no-select'); }
      });
    })();

    // Initialize with a placeholder page
    showPlaceholder();
  </script>
</body>
</html>
