<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Music Library Explorer</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#161a23;
      --panel-2:#0d1118;
      --panel-3:#1b2130;
      --text:#e5e7eb;
      --muted:#9aa3b2;
      --accent:#5b9cff;
      --accent-2:#2f6fe6;
      --border:#222838;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --shadow:0 18px 50px rgba(0,0,0,.35);
      --radius-lg:16px;
      --radius:12px;
      --pad:14px;
      --grid:#2a3246;
      --grid-soft:#20283a;
    }

    /* Light theme override (scoped to app container) */
    .app[data-theme="light"]{
      --bg:#f6f7fb;
      --panel:#ffffff;
      --panel-2:#f2f5fb;
      --panel-3:#eef2fb;
      --text:#0f172a;
      --muted:#5b6474;
      --accent:#2563eb;
      --accent-2:#1e40af;
      --border:#e6e8ee;
      --shadow:0 18px 50px rgba(0,0,0,.08);
      --grid:#e7eaf2;
      --grid-soft:#edf0f7;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family: Inter, Segoe UI, system-ui, -apple-system, Roboto, Helvetica, Arial, sans-serif;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
      line-height:1.55;
    }

    /* (Top bar removed per request) */

    /* App layout */
    .app{
      max-width:1100px; margin:0 auto; padding:24px 16px 48px;
      display:flex; flex-direction:column; gap:18px;
    }

    .card{
      background:var(--panel); border:1px solid var(--border);
      border-radius:var(--radius-lg); box-shadow:var(--shadow); overflow:hidden;
    }
    .card-inner{ padding:18px }
    .card h1{margin:0 0 8px 0; font-size:1.9rem}
    .card p.sub{margin:0; color:var(--muted)}

    /* Picker */
    .picker{ display:flex; flex-direction:column; gap:12px; align-items:center }
    .picker-label{
      display:block; width:100%; max-width:520px; text-align:center; cursor:pointer;
      padding:20px; border-radius:14px; border:1px dashed var(--border); background:var(--panel-2);
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
    }
    .picker-label:hover{ transform:translateY(-1px); border-color:var(--accent) }
    .picker-title{ font-weight:600 }
    .picker-subtitle{ display:block; margin-top:6px; color:var(--muted) }
    .hidden-input{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; border:0; clip:rect(0,0,0,0); overflow:hidden }
    .hint{ color:var(--muted); font-size:.9rem }

    /* Toast-like message */
    .message{ max-width:820px; margin:0 auto; padding:12px 14px; border-radius:12px; border:1px solid var(--border); background:var(--panel-2) }
    .message[data-variant="info"]{ border-left:6px solid var(--accent) }
    .message[data-variant="warning"]{ border-left:6px solid var(--warn) }
    .message[data-variant="danger"]{ border-left:6px solid var(--bad) }

    /* Stats */
    .stats{ display:grid; gap:12px; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); opacity:0; transform:translateY(6px); transition:opacity .2s }
    .stats:not(.hidden){ opacity:1; transform:none }
    .stat-card{ background:var(--panel-2); border:1px solid var(--border); border-radius:14px; padding:16px; display:flex; flex-direction:column; gap:6px }
    .stat-label{ color:var(--muted); font-size:.8rem; text-transform:uppercase; letter-spacing:.06em }
    .stat-value{ font-size:1.6rem; font-weight:700 }

    /* Charts */
    .charts{ display:grid; gap:16px; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); opacity:0; transition:opacity .2s }
    .charts:not(.hidden){ opacity:1 }
    .chart-card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:18px }
    .chart-title{ margin:0 0 10px; font-weight:600 }
    .chart-wrapper{ position:relative; height:320px }
    .chart-card canvas{ display:block; width:100% !important; height:100% !important }

    /* Toolbar */
    .toolbar{ display:flex; gap:10px; align-items:center; background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:12px 14px }
    .toolbar-spacer{ flex:1 }
    .selection-label{ color:var(--muted); font-size:.95rem; overflow:hidden; text-overflow:ellipsis; white-space:nowrap }

    /* Buttons */
    .btn{ appearance:none; border:1px solid var(--border); background:var(--panel-2); color:var(--text); border-radius:10px; padding:8px 12px; cursor:pointer; transition: transform .12s, border-color .12s, background .12s }
    .btn:hover{ transform:translateY(-1px); border-color:var(--accent) }
    .btn.primary{ background:var(--accent); border-color:var(--accent); color:#fff }
    .btn.primary:hover{ background:var(--accent-2); border-color:var(--accent-2) }

    /* Tree */
    .tree{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:18px }
    .tree-folder{ border-left:1px solid rgba(91,156,255,.2); margin-left:0; padding-left:12px }
    .tree-folder:first-of-type{ border-left:none; padding-left:0 }
    .tree-summary{ display:flex; align-items:center; justify-content:space-between; padding:8px 10px; border-radius:10px; cursor:pointer; background:transparent; transition:background .12s }
    .tree-summary:hover{ background:rgba(91,156,255,.08) }
    .tree-label{ font-weight:600 }
    .tree-meta{ color:var(--muted); font-size:.9rem; margin-left:12px }
    .tree-children{ padding-left:12px; margin-left:8px; border-left:1px solid var(--grid); display:grid; gap:8px; margin-top:6px }
    .file-list{ list-style:none; padding-left:0; margin:6px 0 0 0; display:grid; gap:6px }
    .file-item{ display:flex; align-items:center; justify-content:space-between; padding:6px 10px; border-radius:8px; background:var(--panel-2); border:1px solid transparent }
    .file-item:hover{ border-color:var(--accent); background:var(--panel-3) }
    .file-name{ font-family: Segoe UI, Inter, system-ui, -apple-system, Roboto }
    .file-size{ color:var(--muted); font-size:.85rem; margin-left:12px; white-space:nowrap }
    .empty-indicator{ margin:4px 0 0 0; padding:6px 10px; border-radius:8px; background:var(--panel-2); color:var(--muted); font-size:.95rem }

    .hidden{ display:none !important }
    .visually-hidden{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0 }

    @media (max-width:720px){
      .tree{ padding:14px }
      .picker-label{ padding:16px }
      .tree-summary{ flex-direction:column; align-items:flex-start; gap:6px }
      .selection-label{ white-space:normal }
      .toolbar{ flex-direction:column; align-items:stretch }
      .toolbar .btn{ width:100% }
      .toolbar-spacer{ display:none }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="app" id="app" data-theme="dark">
    <section class="card">
      <div class="card-inner">
        <h1>Music Library Explorer</h1>
        <p class="sub">Scan your local music folder to browse artists, albums, and MP3 tracks in a nested tree view. The scan is read-only and stays on this page.</p>
      </div>
    </section>

    <section class="picker" aria-labelledby="pickerTitle">
      <h2 class="visually-hidden" id="pickerTitle">Select Music Folder</h2>
      <label for="folderPicker" class="picker-label">
        <span class="picker-title">Choose Music Folder</span>
        <span class="picker-subtitle">Click to pick the root folder of your library. Subfolders are scanned automatically.</span>
      </label>
      <input type="file" id="folderPicker" class="hidden-input" webkitdirectory multiple />
      <p class="hint">Only MP3 files are listed. Other file types are ignored.</p>
    </section>

    <div id="message" class="message hidden" role="status" aria-live="polite"></div>

    <section id="stats" class="stats hidden" aria-label="Library summary">
      <div class="stat-card">
        <span class="stat-label">Artists</span>
        <span class="stat-value" id="artistCount">0</span>
      </div>
      <div class="stat-card">
        <span class="stat-label">Albums</span>
        <span class="stat-value" id="albumCount">0</span>
      </div>
      <div class="stat-card">
        <span class="stat-label">Tracks</span>
        <span class="stat-value" id="trackCount">0</span>
      </div>
    </section>

    <section id="chartsSection" class="charts hidden" aria-label="Library charts">
      <div class="chart-card">
        <h3 class="chart-title">Top Artists by Tracks</h3>
        <div class="chart-wrapper"><canvas id="topArtistsChart"></canvas></div>
      </div>
      <div class="chart-card">
        <h3 class="chart-title">Top Albums by Tracks</h3>
        <div class="chart-wrapper"><canvas id="topAlbumsChart"></canvas></div>
      </div>
      <div class="chart-card">
        <h3 class="chart-title">Total Size by Artist</h3>
        <div class="chart-wrapper"><canvas id="artistSizeChart"></canvas></div>
      </div>
      <div class="chart-card">
        <h3 class="chart-title">Track Distribution by Artist</h3>
        <div class="chart-wrapper"><canvas id="artistDistributionChart"></canvas></div>
      </div>
    </section>

    <div id="treeToolbar" class="toolbar hidden">
      <button type="button" class="btn" id="expandAll">Expand all</button>
      <button type="button" class="btn" id="expandArtists">Expand Artists</button>
      <button type="button" class="btn" id="collapseAll">Collapse all</button>
      <span class="toolbar-spacer"></span>
      <span class="selection-label" id="selectionLabel"></span>
    </div>

    <section id="treeContainer" class="tree hidden" aria-label="Music library tree"></section>
  </div>

  <noscript>
    <div class="message" data-variant="warning">JavaScript is required to scan and display the music library.</div>
  </noscript>

  <script>
    (function () {
      const appRoot = document.getElementById('app');
      const folderInput = document.getElementById('folderPicker');
      const messageEl = document.getElementById('message');
      const treeContainer = document.getElementById('treeContainer');
      const statsPanel = document.getElementById('stats');
      const artistCountEl = document.getElementById('artistCount');
      const albumCountEl = document.getElementById('albumCount');
      const trackCountEl = document.getElementById('trackCount');
      const toolbar = document.getElementById('treeToolbar');
      const selectionLabel = document.getElementById('selectionLabel');
      const expandAllBtn = document.getElementById('expandAll');
      const collapseAllBtn = document.getElementById('collapseAll');
      const expandArtistsBtn = document.getElementById('expandArtists');
      const chartsSection = document.getElementById('chartsSection');

      const chartInstances = {
        topArtists: null,
        topAlbums: null,
        artistSize: null,
        artistDistribution: null
      };

      let lastFiles = null;

      function getVar(name){
        return getComputedStyle(appRoot).getPropertyValue(name).trim() || '';
      }

      // Theme toggle removed with top bar; default theme is dark.

      if (!('webkitdirectory' in folderInput)) {
        showMessage('This browser does not support folder uploads. Please try Chrome, Edge, or another Chromium-based browser.', 'warning');
      }

      folderInput.addEventListener('change', (event) => {
        const files = Array.from(event.target.files || []);
        if (!files.length) {
          showMessage('No folder selected.', 'warning');
          clearOutput();
          return;
        }
        showMessage('Scanning selected folder...', 'info');
        requestAnimationFrame(() => {
          try {
            const mp3Files = files.filter((file) => file.name.toLowerCase().endsWith('.mp3'));
            if (!mp3Files.length) {
              showMessage('No MP3 files were found in the selected folder.', 'warning');
              clearOutput();
              folderInput.value = '';
              return;
            }
            lastFiles = mp3Files;
            const tree = buildTree(mp3Files);
            renderTree(tree);
            updateStats(mp3Files);
            updateSelectionLabel(Array.from(tree.keys()));
            renderCharts(mp3Files);
            clearMessage();
          } catch (error) {
            console.error('Failed to build library tree:', error);
            showMessage('Something went wrong while scanning the folder.', 'danger');
            clearOutput();
          } finally {
            folderInput.value = '';
          }
        });
      });

      expandAllBtn.addEventListener('click', () => setTreeOpen(true));
      collapseAllBtn.addEventListener('click', () => setTreeOpen(false));
      expandArtistsBtn.addEventListener('click', () => setArtistsExpanded());

      function clearOutput() {
        treeContainer.innerHTML = '';
        treeContainer.classList.add('hidden');
        toolbar.classList.add('hidden');
        statsPanel.classList.add('hidden');
        destroyCharts();
        chartsSection.classList.add('hidden');
        selectionLabel.textContent = '';
      }

      function showMessage(text, variant) {
        messageEl.textContent = text;
        messageEl.dataset.variant = variant || 'info';
        messageEl.classList.remove('hidden');
      }

      function clearMessage() {
        messageEl.textContent = '';
        messageEl.classList.add('hidden');
      }

      function plural(count, singular, pluralForm) {
        return count === 1 ? singular : (pluralForm || singular + 's');
      }

      function formatBytes(bytes) {
        if (!bytes) {
          return '0 B';
        }
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        const index = Math.min(units.length - 1, Math.floor(Math.log(bytes) / Math.log(1024)));
        const value = bytes / Math.pow(1024, index);
        const fixed = value >= 100 ? value.toFixed(0) : value.toFixed(1);
        return fixed + ' ' + units[index];
      }

      function createFolder(name, fullPath) {
        return { name, fullPath, children: new Map(), files: [] };
      }

      function normaliseSegments(path, fallbackRoot) {
        if (!path) {
          return [fallbackRoot || '(selected files)'];
        }
        const parts = path.split('/').filter(Boolean);
        if (!parts.length) {
          return [fallbackRoot || '(selected files)'];
        }
        if (parts.length === 1) {
          return [fallbackRoot || '(selected files)', parts[0]];
        }
        return parts;
      }

      function buildTree(files) {
        const roots = new Map();
        files.forEach((file) => {
          const segments = normaliseSegments(file.webkitRelativePath || file.name, '(selected files)');
          const rootName = segments.shift();
          const fileName = segments.pop() || file.name;
          if (!roots.has(rootName)) {
            roots.set(rootName, createFolder(rootName, rootName));
          }
          let current = roots.get(rootName);
          let currentPath = current.fullPath;
          segments.forEach((segment) => {
            currentPath = currentPath ? currentPath + '/' + segment : segment;
            if (!current.children.has(segment)) {
              current.children.set(segment, createFolder(segment, currentPath));
            }
            current = current.children.get(segment);
          });
          const fullPath = currentPath ? currentPath + '/' + fileName : fileName;
          current.files.push({
            name: fileName,
            size: file.size,
            fullPath: fullPath
          });
        });
        return roots;
      }

      function renderTree(roots) {
        const fragment = document.createDocumentFragment();
        const sortedRoots = Array.from(roots.values()).sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base', numeric: true }));
        sortedRoots.forEach((rootNode) => {
          fragment.appendChild(renderFolder(rootNode, 0));
        });
        treeContainer.innerHTML = '';
        treeContainer.appendChild(fragment);
        treeContainer.classList.remove('hidden');
        toolbar.classList.remove('hidden');
      }

      function renderFolder(node, depth) {
        const details = document.createElement('details');
        details.className = 'tree-folder';
        details.dataset.depth = String(depth);
        if (depth <= 1) {
          details.open = true;
        }

        const summary = document.createElement('summary');
        summary.className = 'tree-summary';

        const label = document.createElement('span');
        label.className = 'tree-label';
        label.textContent = node.name || (depth === 0 ? 'Root' : '(unnamed)');

        const meta = document.createElement('span');
        meta.className = 'tree-meta';
        const folderCount = node.children.size;
        const trackCount = node.files.length;
        const segments = [];
        if (folderCount) {
          segments.push(folderCount + ' ' + plural(folderCount, 'folder'));
        }
        if (trackCount) {
          segments.push(trackCount + ' ' + plural(trackCount, 'track'));
        }
        meta.textContent = segments.join(' | ') || 'Empty';

        summary.appendChild(label);
        summary.appendChild(meta);
        details.appendChild(summary);

        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'tree-children';

        const childFolders = Array.from(node.children.values()).sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base', numeric: true }));
        childFolders.forEach((child) => {
          childrenContainer.appendChild(renderFolder(child, depth + 1));
        });

        if (node.files.length) {
          const list = document.createElement('ul');
          list.className = 'file-list';
          const sortedFiles = node.files.slice().sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base', numeric: true }));
          sortedFiles.forEach((file) => {
            const item = document.createElement('li');
            item.className = 'file-item';
            const nameSpan = document.createElement('span');
            nameSpan.className = 'file-name';
            nameSpan.textContent = file.name;
            const sizeSpan = document.createElement('span');
            sizeSpan.className = 'file-size';
            sizeSpan.textContent = formatBytes(file.size);
            item.appendChild(nameSpan);
            item.appendChild(sizeSpan);
            item.title = file.fullPath + ' (' + formatBytes(file.size) + ')';
            list.appendChild(item);
          });
          childrenContainer.appendChild(list);
        }

        if (!childFolders.length && !node.files.length) {
          const emptyNote = document.createElement('p');
          emptyNote.className = 'empty-indicator';
          emptyNote.textContent = 'No tracks in this folder.';
          childrenContainer.appendChild(emptyNote);
        }

        details.appendChild(childrenContainer);
        return details;
      }

      function updateStats(files) {
        const artists = new Set();
        const albums = new Set();
        files.forEach((file) => {
          const segments = normaliseSegments(file.webkitRelativePath || file.name, '(selected files)');
          if (segments.length >= 3) {
            artists.add(segments[1]);
          }
          if (segments.length >= 4) {
            albums.add(segments[1] + '::' + segments[2]);
          }
        });
        artistCountEl.textContent = artists.size;
        albumCountEl.textContent = albums.size;
        trackCountEl.textContent = files.length;
        statsPanel.classList.remove('hidden');
      }

      function updateSelectionLabel(rootNames) {
        if (!rootNames.length) {
          selectionLabel.textContent = '';
          return;
        }
        if (rootNames.length === 1) {
          selectionLabel.textContent = 'Selected folder: ' + rootNames[0];
        } else {
          selectionLabel.textContent = 'Selected folders: ' + rootNames.join(', ');
        }
      }

      function setTreeOpen(open) {
        const detailsList = treeContainer.querySelectorAll('details.tree-folder');
        detailsList.forEach((detail) => {
          const depth = Number(detail.dataset.depth || 0);
          if (open) {
            detail.setAttribute('open', '');
          } else if (depth === 0) {
            detail.setAttribute('open', '');
          } else {
            detail.removeAttribute('open');
          }
        });
      }

      function setArtistsExpanded() {
        const detailsList = treeContainer.querySelectorAll('details.tree-folder');
        detailsList.forEach((detail) => {
          const depth = Number(detail.dataset.depth || 0);
          if (depth <= 1) {
            detail.setAttribute('open', '');
          } else {
            detail.removeAttribute('open');
          }
        });
      }

      // --- Charts & Analytics ---
      function prepareAnalytics(files) {
        const artistCounts = new Map();
        const albumCounts = new Map();
        const artistSizes = new Map();

        files.forEach((file) => {
          const segments = normaliseSegments(file.webkitRelativePath || file.name, '(selected files)');
          if (segments.length >= 3) {
            const artist = segments[1];
            artistCounts.set(artist, (artistCounts.get(artist) || 0) + 1);
            artistSizes.set(artist, (artistSizes.get(artist) || 0) + file.size);
            if (segments.length >= 4) {
              const album = segments[2];
              const albumKey = artist + ' â€” ' + album;
              albumCounts.set(albumKey, (albumCounts.get(albumKey) || 0) + 1);
            }
          }
        });

        return { artistCounts, albumCounts, artistSizes };
      }

      function topEntriesFromMap(map, limit) {
        return Array.from(map.entries())
          .sort((a, b) => Number(b[1]) - Number(a[1]))
          .slice(0, limit);
      }

      function destroyCharts() {
        Object.keys(chartInstances).forEach((key) => {
          if (chartInstances[key]) {
            try { chartInstances[key].destroy(); } catch (_) {}
            chartInstances[key] = null;
          }
        });
      }

      function renderCharts(files) {
        const { artistCounts, albumCounts, artistSizes } = prepareAnalytics(files);
        destroyCharts();

        const topArtistsByTracks = topEntriesFromMap(artistCounts, 20);
        const topAlbumsByTracks = topEntriesFromMap(albumCounts, 20);
        const topArtistsBySize = topEntriesFromMap(artistSizes, 20);

        if (!topArtistsByTracks.length && !topAlbumsByTracks.length && !topArtistsBySize.length) {
          chartsSection.classList.add('hidden');
          return;
        }
        chartsSection.classList.remove('hidden');

        const textColor = getVar('--text') || 'rgba(226,232,240,0.9)';
        const gridColor = getVar('--grid') || 'rgba(148,163,184,0.15)';
        const gridSoft = getVar('--grid-soft') || 'rgba(148,163,184,0.1)';

        chartInstances.topArtists = createHorizontalBarChart(
          'topArtistsChart',
          topArtistsByTracks.map(([name]) => name),
          {
            label: 'Tracks',
            data: topArtistsByTracks.map(([, count]) => count),
            backgroundColor: 'rgba(91, 156, 255, 0.75)',
            borderColor: 'rgba(91, 156, 255, 1)',
            borderWidth: 1
          },
          {
            plugins: { tooltip: { callbacks: { label: (ctx) => 'Tracks: ' + ctx.parsed.x } } },
            scales: { x: { ticks: { precision: 0 } } },
            colorVars: { textColor, gridColor, gridSoft }
          }
        );

        chartInstances.topAlbums = createHorizontalBarChart(
          'topAlbumsChart',
          topAlbumsByTracks.map(([name]) => name),
          {
            label: 'Tracks',
            data: topAlbumsByTracks.map(([, count]) => count),
            backgroundColor: 'rgba(34, 197, 94, 0.75)',
            borderColor: 'rgba(34, 197, 94, 1)',
            borderWidth: 1
          },
          {
            plugins: { tooltip: { callbacks: { label: (ctx) => 'Tracks: ' + ctx.parsed.x } } },
            scales: { x: { ticks: { precision: 0 } } },
            colorVars: { textColor, gridColor, gridSoft }
          }
        );

        chartInstances.artistSize = createHorizontalBarChart(
          'artistSizeChart',
          topArtistsBySize.map(([name]) => name),
          {
            label: 'Total Size',
            data: topArtistsBySize.map(([, size]) => size),
            backgroundColor: 'rgba(239, 68, 68, 0.75)',
            borderColor: 'rgba(239, 68, 68, 1)',
            borderWidth: 1
          },
          {
            plugins: { tooltip: { callbacks: { label: (ctx) => 'Size: ' + formatBytes(ctx.parsed.x) } } },
            scales: { x: { ticks: { callback: (v) => formatBytes(v) } } },
            colorVars: { textColor, gridColor, gridSoft }
          }
        );

        const sortedArtists = Array.from(artistCounts.entries()).sort((a, b) => b[1] - a[1]);
        const top = sortedArtists.slice(0, 12);
        const othersTotal = sortedArtists.slice(12).reduce((sum, [, v]) => sum + v, 0);
        const pieLabels = top.map(([name]) => name).concat(othersTotal ? ['Others'] : []);
        const pieData = top.map(([, v]) => v).concat(othersTotal ? [othersTotal] : []);
        chartInstances.artistDistribution = renderPieChart('artistDistributionChart', pieLabels, pieData, { textColor });
      }

      function createHorizontalBarChart(canvasId, labels, dataset, options = {}) {
        const canvas = document.getElementById(canvasId);
        const ctx = canvas.getContext('2d');
        const textColor = options.colorVars?.textColor || 'rgba(226,232,240,0.9)';
        const gridColor = options.colorVars?.gridColor || 'rgba(148,163,184,0.15)';
        const gridSoft = options.colorVars?.gridSoft || 'rgba(148,163,184,0.1)';
        const defaultOptions = {
          indexAxis: 'y',
          maintainAspectRatio: false,
          responsive: true,
          resizeDelay: 200,
          animation: false,
          scales: {
            x: { beginAtZero: true, ticks: { color: textColor, precision: 0 }, grid: { color: gridColor } },
            y: { ticks: { color: textColor }, grid: { color: gridSoft } }
          },
          plugins: { legend: { display: false } }
        };
        const { colorVars, ...rest } = options;
        return new Chart(ctx, {
          type: 'bar',
          data: { labels, datasets: [dataset] },
          options: { ...defaultOptions, ...rest }
        });
      }

      function renderPieChart(canvasId, labels, data, theme = {}) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        const textColor = theme.textColor || 'rgba(226,232,240,0.9)';
        return new Chart(ctx, {
          type: 'pie',
          data: {
            labels,
            datasets: [{
              data,
              backgroundColor: ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899', '#6366F1', '#06B6D4', '#D97706', '#65A30D', '#4F46E5', '#F97316', '#14B8A6']
            }]
          },
          options: {
            maintainAspectRatio: false,
            responsive: true,
            resizeDelay: 200,
            animation: false,
            plugins: {
              legend: { position: 'bottom', labels: { color: textColor } },
              tooltip: {
                callbacks: {
                  label: (context) => {
                    const label = context.label || '';
                    const value = context.parsed || 0;
                    const total = (context.dataset.data || []).reduce((s, v) => s + v, 0) || 0;
                    const pct = total ? ((value / total) * 100).toFixed(1) : '0.0';
                    return label + ': ' + value + ' tracks (' + pct + '%)';
                  }
                }
              }
            }
          }
        });
      }
    })();
  </script>
</body>
</html>
