<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Repo to Plain Text | Convert GitHub Repos to Text</title>
    <meta name="description" content="Convert GitHub repositories to a single formatted plain text file. Browse, select files, and export.">
    <style>
        body { background-color: #1a202c; color: #e2e8f0; }
        .directory-checkbox + button:focus { outline: none; }
        .directory-checkbox + button:hover { color: #cbd5e0; }
        .max-w-4xl { background-color: #2d3748; color: #e2e8f0; }
        input, textarea { background-color: #4a5568; color: #edf2f7; border: 1px solid #718096; }
        input:focus, textarea:focus { border-color: #63b3ed; outline: none; }
        button { transition: background-color 0.3s; }
        button.bg-blue-500 { background-color: #4299e1; }
        button.bg-blue-500:hover { background-color: #3182ce; }
        button.bg-green-500 { background-color: #48bb78; }
        button.bg-green-500:hover { background-color: #38a169; }
        button.bg-indigo-500 { background-color: #667eea; }
        button.bg-indigo-500:hover { background-color: #5a67d8; }
        button.bg-purple-500 { background-color: #9f7aea; }
        button.bg-purple-500:hover { background-color: #805ad5; }
        .text-gray-600 { color: #a0aec0; }
        .text-gray-500 { color: #cbd5e0; }
        a i { color: #e2e8f0; }
        a i:hover { color: #edf2f7; }
        .rounded-md { background-color: #2d3748; border-color: #4a5568; }
        ul { list-style: none; padding-left: 0; }
    </style>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
</head>
<body class="bg-gray-900 min-h-screen p-4 md:p-8 text-gray-200">
    <div class="max-w-4xl mx-auto bg-gray-800 rounded-lg shadow-md p-6 relative">
        <h1 class="text-3xl font-bold mb-2 text-center text-gray-200">GitHub to Plain Text</h1>
        <p class="text-lg text-center text-gray-400 mb-6">Convert Code in GitHub to a Single Formatted Text File</p>

        <!-- How to use:
             1) Paste a GitHub URL like https://github.com/owner/repo or https://github.com/owner/repo/tree/branch/path
             2) (Optional) Add a Personal Access Token for private repos or higher rate limits
             3) Fetch directory structure, select files, then Generate, Copy, or Download the result -->

        <form id="repoForm" class="space-y-4">
            <div>
                <label for="repoUrl" class="block text-sm font-medium text-gray-300">GitHub URL:</label>
                <input type="text" id="repoUrl" name="repoUrl" required class="mt-1 block w-full rounded-md border border-gray-600 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 h-10 px-2" placeholder="https://github.com/owner/repo or .../tree/branch/path">
            </div>
            <div class="hidden">
                <label for="ref" class="block text-sm font-medium text-gray-300">Ref (branch/tag/commit sha):</label>
                <input type="text" id="ref" name="ref" class="mt-1 block w-full rounded-md border border-gray-600 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 h-10 px-2">
            </div>
            <div class="hidden">
                <label for="path" class="block text-sm font-medium text-gray-300">Path (subdirectory):</label>
                <input type="text" id="path" name="path" class="mt-1 block w-full rounded-md border border-gray-600 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 h-10 px-2">
            </div>
            <div>
                <label for="accessToken" class="block text-sm font-medium text-gray-300 flex items-center">
                    Personal Access Token (optional - for private repositories and higher rate limits):
                    <button type="button" id="showMoreInfo" class="ml-2 text-blue-500 hover:text-blue-400" title="Toggle token info">
                        <i data-lucide="info" class="w-4 h-4"></i>
                    </button>
                </label>
                <div id="tokenInfo" class="hidden mt-2">
                    <p class="text-sm text-gray-400">This runs entirely in your browser. Your token is only used for requests you make and is not stored.</p>
                    <p class="mt-1"><a href="https://github.com/settings/tokens/new?description=repo2file&scopes=repo" target="_blank" rel="noopener" class="text-sm text-blue-500 hover:text-blue-400"><i data-lucide="external-link" class="w-5 h-5 inline-block"></i> Get a token</a></p>
                </div>
                <input type="text" id="accessToken" name="accessToken" class="mt-1 block w-full rounded-md border border-gray-600 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 h-10 px-2" placeholder="ghp_... (optional)">
            </div>
            <button type="submit" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline flex items-center justify-center">
                <i data-lucide="folder-search" class="w-5 h-5 mr-2"></i>
                Fetch Directory Structure
            </button>
        </form>

        <div id="directoryStructure" class="mt-6"></div>
        <button id="generateTextButton" class="mt-4 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline hidden flex items-center justify-center">
            <i data-lucide="file-text" class="w-5 h-5 mr-2"></i>
            Generate Text File
        </button>
    <textarea id="outputText" rows="20" class="mt-4 w-full p-2 border rounded-md font-mono" aria-label="Output text" placeholder="Generated text will appear here" readonly></textarea>
        <div class="mt-4 flex space-x-4">
            <button id="copyButton" class="flex-1 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline hidden flex items-center justify-center">
                <i data-lucide="copy" class="w-5 h-5 mr-2"></i>
                Copy to Clipboard
            </button>
            <button id="downloadButton" class="flex-1 bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline hidden flex items-center justify-center">
                <i data-lucide="download" class="w-5 h-5 mr-2"></i>
                Download
            </button>
        </div>
    </div>

    <script>
    // Core interactions: fetch repo tree, display selectable structure, fetch selected files, format to text
    document.getElementById('repoForm').addEventListener('submit', async function (e) {
        e.preventDefault();
        const repoUrl = document.getElementById('repoUrl').value;
        const ref = document.getElementById('ref').value || '';
        const path = document.getElementById('path').value || '';
        const accessToken = document.getElementById('accessToken').value;

        const outputText = document.getElementById('outputText');
        outputText.value = '';

        try {
            const { owner, repo, refFromUrl, pathFromUrl } = parseRepoUrl(repoUrl);
            const finalRef = ref || refFromUrl;
            const finalPath = path || pathFromUrl;

            const sha = await fetchRepoSha(owner, repo, finalRef, finalPath, accessToken);
            const tree = await fetchRepoTree(owner, repo, sha, accessToken);

            displayDirectoryStructure(tree);
            document.getElementById('generateTextButton').style.display = 'flex';
        } catch (error) {
            outputText.value = `Error fetching repository contents: ${error.message}\n\nPlease ensure:\n1. The repository URL is correct and accessible.\n2. You have the necessary permissions to access the repository.\n3. If it's a private repository, you've provided a valid access token.\n4. The specified branch/tag and path (if any) exist in the repository.`;
        }
    });

    document.getElementById('generateTextButton').addEventListener('click', async function () {
        const accessToken = document.getElementById('accessToken').value;
        const outputText = document.getElementById('outputText');
        outputText.value = '';

        try {
            const selectedFiles = getSelectedFiles();
            if (selectedFiles.length === 0) {
                throw new Error('No files selected');
            }
            const fileContents = await fetchFileContents(selectedFiles, accessToken);
            const formattedText = formatRepoContents(fileContents);
            outputText.value = formattedText;

            document.getElementById('copyButton').style.display = 'flex';
            document.getElementById('downloadButton').style.display = 'flex';
        } catch (error) {
            outputText.value = `Error generating text file: ${error.message}\n\nPlease ensure:\n1. You have selected at least one file from the directory structure.\n2. Your access token (if provided) is valid and has the necessary permissions.\n3. You have a stable internet connection.\n4. The GitHub API is accessible and functioning normally.`;
        }
    });

    document.getElementById('copyButton').addEventListener('click', function () {
        const outputText = document.getElementById('outputText');
        outputText.select();
        navigator.clipboard.writeText(outputText.value).then(() => {
            console.log('Text copied to clipboard');
        }).catch(err => {
            console.error('Failed to copy text: ', err);
        });
    });

    document.getElementById('downloadButton').addEventListener('click', function () {
        const outputText = document.getElementById('outputText').value;
        if (!outputText.trim()) {
            document.getElementById('outputText').value = 'Error: No content to download. Please generate the text file first.';
            return;
        }
        const blob = new Blob([outputText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'repository.txt';
        a.click();
        URL.revokeObjectURL(url);
    });

    function parseRepoUrl(url) {
        url = url.replace(/\/$/, '');
        const urlPattern = /^https:\/\/github\.com\/([^\/]+)\/([^\/]+)(\/tree\/([^\/]+)(\/(.+))?)?$/;
        const match = url.match(urlPattern);
        if (!match) {
            throw new Error('Invalid GitHub repository URL. Use https://github.com/owner/repo or https://github.com/owner/repo/tree/branch/path');
        }
        return {
            owner: match[1],
            repo: match[2],
            refFromUrl: match[4],
            pathFromUrl: match[6]
        };
    }

    async function fetchRepoSha(owner, repo, ref, path, token) {
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path ? `${path}` : ''}${ref ? `?ref=${ref}` : ''}`;
        const headers = { 'Accept': 'application/vnd.github.object+json' };
        if (token) headers['Authorization'] = `token ${token}`;
        const response = await fetch(url, { headers });
        if (!response.ok) {
            if (response.status === 403 && response.headers.get('X-RateLimit-Remaining') === '0') {
                throw new Error('GitHub API rate limit exceeded. Try later or provide a token.');
            }
            if (response.status === 404) {
                throw new Error('Repository, branch, or path not found.');
            }
            throw new Error(`Failed to fetch repository SHA. Status: ${response.status}`);
        }
        const data = await response.json();
        return data.sha;
    }

    async function fetchRepoTree(owner, repo, sha, token) {
        const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${sha}?recursive=1`;
        const headers = { 'Accept': 'application/vnd.github+json' };
        if (token) headers['Authorization'] = `token ${token}`;
        const response = await fetch(url, { headers });
        if (!response.ok) {
            if (response.status === 403 && response.headers.get('X-RateLimit-Remaining') === '0') {
                throw new Error('GitHub API rate limit exceeded. Try later or provide a token.');
            }
            throw new Error(`Failed to fetch repository tree. Status: ${response.status}`);
        }
        const data = await response.json();
        return data.tree;
    }

    function displayDirectoryStructure(tree) {
        tree = tree.filter(item => item.type === 'blob');
        tree = sortContents(tree);
        const container = document.getElementById('directoryStructure');
        container.innerHTML = '';
        const rootUl = document.createElement('ul');
        container.appendChild(rootUl);

        const directoryStructure = {};

        tree.forEach(item => {
            item.path = item.path.startsWith('/') ? item.path : '/' + item.path;
            const pathParts = item.path.split('/');
            let currentLevel = directoryStructure;

            pathParts.forEach((part, index) => {
                if (part === '') { part = './'; }
                if (!currentLevel[part]) {
                    currentLevel[part] = index === pathParts.length - 1 ? item : {};
                }
                currentLevel = currentLevel[part];
            });
        });

        function createTreeNode(name, item, parentUl) {
            const li = document.createElement('li');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            const commonExtensions = ['.js', '.py', '.java', '.cpp', '.html', '.css', '.ts', '.jsx', '.tsx'];
            const fileName = name.toLowerCase();
            const isCommonFile = commonExtensions.some(ext => fileName.endsWith(ext));
            checkbox.checked = isCommonFile;
            checkbox.className = 'mr-2';

            if (typeof item === 'object' && (!item.type || typeof item.type !== 'string')) {
                // Directory
                checkbox.classList.add('directory-checkbox');
                li.appendChild(checkbox);

                const collapseButton = document.createElement('button');
                collapseButton.innerHTML = '<i data-lucide="chevron-down" class="w-4 h-4"></i>';
                collapseButton.className = 'mr-1 focus:outline-none';
                li.appendChild(collapseButton);

                const folderIcon = document.createElement('i');
                folderIcon.setAttribute('data-lucide', 'folder');
                folderIcon.className = 'inline-block w-4 h-4 mr-1';
                li.appendChild(folderIcon);
                li.appendChild(document.createTextNode(name));
                const ul = document.createElement('ul');
                ul.className = 'ml-6 mt-2';
                li.appendChild(ul);

                for (const [childName, childItem] of Object.entries(item)) {
                    createTreeNode(childName, childItem, ul);
                }

                checkbox.addEventListener('change', function() {
                    const childCheckboxes = li.querySelectorAll('input[type="checkbox"]');
                    childCheckboxes.forEach(childBox => {
                        childBox.checked = this.checked;
                        childBox.indeterminate = false;
                    });
                });

                collapseButton.addEventListener('click', function() {
                    ul.classList.toggle('hidden');
                    const icon = this.querySelector('[data-lucide]');
                    if (ul.classList.contains('hidden')) {
                        icon.setAttribute('data-lucide', 'chevron-right');
                    } else {
                        icon.setAttribute('data-lucide', 'chevron-down');
                    }
                    lucide.createIcons();
                });
            } else {
                // File
                checkbox.value = JSON.stringify({ url: item.url, path: item.path });
                li.appendChild(checkbox);
                const fileIcon = document.createElement('i');
                fileIcon.setAttribute('data-lucide', 'file');
                fileIcon.className = 'inline-block w-4 h-4 mr-1';
                li.appendChild(fileIcon);
                li.appendChild(document.createTextNode(name));
            }

            li.className = 'my-2';
            parentUl.appendChild(li);
            updateParentCheckbox(checkbox);
        }

        for (const [name, item] of Object.entries(directoryStructure)) {
            createTreeNode(name, item, rootUl);
        }

        container.addEventListener('change', function(event) {
            if (event.target.type === 'checkbox') {
                updateParentCheckbox(event.target);
            }
        });

        function updateParentCheckbox(checkbox) {
            if (!checkbox) return;
            const li = checkbox.closest('li');
            if (!li) return;
            if (!li.parentElement) return;
            const parentLi = li.parentElement.closest('li');
            if (!parentLi) return;

            const parentCheckbox = parentLi.querySelector(':scope > input[type="checkbox"]');
            const siblingCheckboxes = parentLi.querySelectorAll(':scope > ul > li > input[type="checkbox"]');

            const checkedCount = Array.from(siblingCheckboxes).filter(cb => cb.checked).length;
            const indeterminateCount = Array.from(siblingCheckboxes).filter(cb => cb.indeterminate).length;

            if (indeterminateCount !== 0) {
                parentCheckbox.checked = false;
                parentCheckbox.indeterminate = true;
            } else if (checkedCount === 0) {
                parentCheckbox.checked = false;
                parentCheckbox.indeterminate = false;
            } else if (checkedCount === siblingCheckboxes.length) {
                parentCheckbox.checked = true;
                parentCheckbox.indeterminate = false;
            } else {
                parentCheckbox.checked = false;
                parentCheckbox.indeterminate = true;
            }

            updateParentCheckbox(parentCheckbox);
        }

        lucide.createIcons();
    }

    function getSelectedFiles() {
        const checkboxes = document.querySelectorAll('#directoryStructure input[type="checkbox"]:checked:not(.directory-checkbox)');
        return Array.from(checkboxes).map(checkbox => JSON.parse(checkbox.value));
    }

    async function fetchFileContents(files, token) {
        const headers = { 'Accept': 'application/vnd.github.v3.raw' };
        if (token) headers['Authorization'] = `token ${token}`;
        const contents = await Promise.all(files.map(async file => {
            const response = await fetch(file.url, { headers });
            if (!response.ok) {
                if (response.status === 403 && response.headers.get('X-RateLimit-Remaining') === '0') {
                    throw new Error(`GitHub API rate limit exceeded while fetching ${file.path}. Try later or provide a token.`);
                }
                throw new Error(`Failed to fetch content for ${file.path}. Status: ${response.status}`);
            }
            const text = await response.text();
            return { url: file.url, path: file.path, text };
        }));
        return contents;
    }

    function formatRepoContents(contents) {
        let text = '';
        let index = '';

        contents = sortContents(contents);

        const tree = {};
        contents.forEach(item => {
            const parts = item.path.split('/');
            let currentLevel = tree;
            parts.forEach((part, i) => {
                if (!currentLevel[part]) {
                    currentLevel[part] = i === parts.length - 1 ? null : {};
                }
                currentLevel = currentLevel[part];
            });
        });

        function buildIndex(node, prefix = '') {
            let result = '';
            const entries = Object.entries(node);
            entries.forEach(([name, subNode], idx) => {
                const isLastItem = idx === entries.length - 1;
                const linePrefix = isLastItem ? '└── ' : '├── ';
                const childPrefix = isLastItem ? '    ' : '│   ';

                if (name === '') { name = './'; }

                result += `${prefix}${linePrefix}${name}\n`;
                if (subNode) {
                    result += buildIndex(subNode, `${prefix}${childPrefix}`);
                }
            });
            return result;
        }

        index = buildIndex(tree);

        contents.forEach((item) => {
            text += `\n\n---\nFile: ${item.path}\n---\n\n${item.text}\n`;
        });

        return `Directory Structure:\n\n${index}\n${text}`;
    }

    function sortContents(contents) {
        contents.sort((a, b) => {
            const aPath = a.path.split('/');
            const bPath = b.path.split('/');
            const minLength = Math.min(aPath.length, bPath.length);

            for (let i = 0; i < minLength; i++) {
                if (aPath[i] !== bPath[i]) {
                    if (i === aPath.length - 1 && i < bPath.length - 1) return 1;
                    if (i === bPath.length - 1 && i < aPath.length - 1) return -1;
                    return aPath[i].localeCompare(bPath[i]);
                }
            }

            return aPath.length - bPath.length;
        });
        return contents;
    }

    document.addEventListener('DOMContentLoaded', function() {
        lucide.createIcons();

        const showMoreInfoButton = document.getElementById('showMoreInfo');
        const tokenInfo = document.getElementById('tokenInfo');

        showMoreInfoButton.addEventListener('click', function() {
            tokenInfo.classList.toggle('hidden');
            const icon = this.querySelector('[data-lucide]');
            if (icon) {
                if (tokenInfo.classList.contains('hidden')) {
                    icon.setAttribute('data-lucide', 'info');
                } else {
                    icon.setAttribute('data-lucide', 'x');
                }
                lucide.createIcons();
            }
        });
    });
    </script>
</body>
</html>